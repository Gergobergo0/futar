/*
 * realCity Query Server API
 * Specification for the realCity Query Server API.
 *
 * The version of the OpenAPI document: 1.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.AlertSearchMethodResponse;
import org.openapitools.client.model.ApiVersion;
import org.openapitools.client.model.ArrivalsAndDeparturesForLocationOTPMethodResponse;
import org.openapitools.client.model.ArrivalsAndDeparturesForStopOTPMethodResponse;
import org.openapitools.client.model.BicycleRentalMethodResponse;
import org.openapitools.client.model.Dialect;
import org.openapitools.client.model.MetadataResponse;
import org.openapitools.client.model.MultiRouteDetailsMethodResponse;
import java.time.OffsetDateTime;
import org.openapitools.client.model.OnboardDepartPosition;
import org.openapitools.client.model.OnboardDepartSearchMethodResponse;
import org.openapitools.client.model.PlanTripResponse;
import org.openapitools.client.model.ReferencesMethodResponse;
import org.openapitools.client.model.ReferencesSchema;
import org.openapitools.client.model.RouteDetailsForStopMethodResponse;
import org.openapitools.client.model.RouteDetailsMethodResponse;
import org.openapitools.client.model.ScheduleForStopOTPMethodResponse;
import org.openapitools.client.model.SearchMethodResponse;
import org.openapitools.client.model.StatisticsResponse;
import org.openapitools.client.model.StopsForLocationResponse;
import org.openapitools.client.model.TicketingMethodResponse;
import org.openapitools.client.model.TraverseMode;
import org.openapitools.client.model.TripDetailsOTPMethodResponse;
import org.openapitools.client.model.VehicleForTripMethodResponse;
import org.openapitools.client.model.VehiclesForLocationMethodResponse;
import org.openapitools.client.model.VehiclesForRouteMethodResponse;
import org.openapitools.client.model.VehiclesForStopMethodResponse;
import org.openapitools.client.model.WalkProfile;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class DefaultApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public DefaultApi() {
        this(Configuration.getDefaultApiClient());
    }

    public DefaultApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for bookingRedirect
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param routeId A járat azonosítója. (optional)
     * @param directionId A járat íránya. (optional)
     * @param tripId A menet azonosítója. (optional)
     * @param serviceDate A menet üzem napja. (optional)
     * @param boardStopId A felszállási megálló azonosítója. (optional)
     * @param alightStopId A leszállási megálló azonosítója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 302 </td><td> Átírányit a foglalási oldalra. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call bookingRedirectCall(Dialect dialect, String routeId, String directionId, String tripId, String serviceDate, String boardStopId, String alightStopId, ApiVersion version, String appVersion, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/{dialect}/api/where/booking-redirect"
            .replace("{" + "dialect" + "}", localVarApiClient.escapeString(dialect.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (routeId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("routeId", routeId));
        }

        if (directionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("directionId", directionId));
        }

        if (tripId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tripId", tripId));
        }

        if (serviceDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("serviceDate", serviceDate));
        }

        if (boardStopId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("boardStopId", boardStopId));
        }

        if (alightStopId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("alightStopId", alightStopId));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("version", version));
        }

        if (appVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("appVersion", appVersion));
        }

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyQuery" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call bookingRedirectValidateBeforeCall(Dialect dialect, String routeId, String directionId, String tripId, String serviceDate, String boardStopId, String alightStopId, ApiVersion version, String appVersion, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'dialect' is set
        if (dialect == null) {
            throw new ApiException("Missing the required parameter 'dialect' when calling bookingRedirect(Async)");
        }

        return bookingRedirectCall(dialect, routeId, directionId, tripId, serviceDate, boardStopId, alightStopId, version, appVersion, _callback);

    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param routeId A járat azonosítója. (optional)
     * @param directionId A járat íránya. (optional)
     * @param tripId A menet azonosítója. (optional)
     * @param serviceDate A menet üzem napja. (optional)
     * @param boardStopId A felszállási megálló azonosítója. (optional)
     * @param alightStopId A leszállási megálló azonosítója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 302 </td><td> Átírányit a foglalási oldalra. </td><td>  -  </td></tr>
     </table>
     */
    public void bookingRedirect(Dialect dialect, String routeId, String directionId, String tripId, String serviceDate, String boardStopId, String alightStopId, ApiVersion version, String appVersion) throws ApiException {
        bookingRedirectWithHttpInfo(dialect, routeId, directionId, tripId, serviceDate, boardStopId, alightStopId, version, appVersion);
    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param routeId A járat azonosítója. (optional)
     * @param directionId A járat íránya. (optional)
     * @param tripId A menet azonosítója. (optional)
     * @param serviceDate A menet üzem napja. (optional)
     * @param boardStopId A felszállási megálló azonosítója. (optional)
     * @param alightStopId A leszállási megálló azonosítója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 302 </td><td> Átírányit a foglalási oldalra. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> bookingRedirectWithHttpInfo(Dialect dialect, String routeId, String directionId, String tripId, String serviceDate, String boardStopId, String alightStopId, ApiVersion version, String appVersion) throws ApiException {
        okhttp3.Call localVarCall = bookingRedirectValidateBeforeCall(dialect, routeId, directionId, tripId, serviceDate, boardStopId, alightStopId, version, appVersion, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param routeId A járat azonosítója. (optional)
     * @param directionId A járat íránya. (optional)
     * @param tripId A menet azonosítója. (optional)
     * @param serviceDate A menet üzem napja. (optional)
     * @param boardStopId A felszállási megálló azonosítója. (optional)
     * @param alightStopId A leszállási megálló azonosítója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 302 </td><td> Átírányit a foglalási oldalra. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call bookingRedirectAsync(Dialect dialect, String routeId, String directionId, String tripId, String serviceDate, String boardStopId, String alightStopId, ApiVersion version, String appVersion, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = bookingRedirectValidateBeforeCall(dialect, routeId, directionId, tripId, serviceDate, boardStopId, alightStopId, version, appVersion, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for getArrivalsAndDeparturesForLocation
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param groupLimit Menetrendi adatok maximális száma egy csoportban. (optional, default to 4)
     * @param clientLon A kliens hosszúsági koordinátája. (optional, default to 0)
     * @param clientLat A kliens szélességi koordinátája. (optional, default to 0)
     * @param minutesBefore A lekérdezési időablak a &#x60;time&#x60; paraméter előtt ennyi perccel indul. (optional, default to 2)
     * @param minutesAfter A lekérdezési időablak a &#x60;time&#x60; paraméter után ennyi perccel ér véget. (optional, default to 30)
     * @param stopId A megállók azonosítóinak listája, amelyekhez a lekérést végezzük. (optional)
     * @param includeRouteId A válasz szűrésére használt járatok azonosítóinak listája. (optional)
     * @param time A lekérdezés kiértékeléséhez használt időpont. Alapértelmezetten az aktuális szerveridő. (optional)
     * @param onlyDepartures Ha igaz akkor csak az érkezési (és előrejelzett érkezési) idők nem szerepelnek a válaszban. (optional, default to true)
     * @param limit A visszaadott indulási és érkezési idők listájának maximális hossza. (optional, default to 60)
     * @param lat A helyszín középpontjának szélessgéi koordinátája. (optional)
     * @param lon A helyszín középpontjának hosszúsági koordinátája. (optional)
     * @param latSpan A lekérési terület szélességi íve. (Terület szélessége: &#x60;lat +/- latspan&#x60;). (optional)
     * @param lonSpan A lekérési terület hosszúsági íve. (Terület hosszúsága: &#x60;lon +/- lonSpan&#x60;). (optional)
     * @param radius Ha a &#x60;latSpan&#x60; vagy a &#x60;longSpan&#x60; nincs kitöltve, a keresési terület a középpontól számított &#x60;radius&#x60; méter távolság mind a négy irányban. (optional, default to 100)
     * @param query A válasz szűrésére használt keresési kifejezés. (optional)
     * @param minResult A visszaadott elemek minimális száma. (optional, default to 5)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszaadja egy területhez tartozó érkezési és indulási időket járatazonosítók és célállomások szerint csoportosítva. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getArrivalsAndDeparturesForLocationCall(Dialect dialect, Integer groupLimit, Double clientLon, Double clientLat, Integer minutesBefore, Integer minutesAfter, List<String> stopId, List<String> includeRouteId, Long time, Boolean onlyDepartures, Integer limit, Float lat, Float lon, Float latSpan, Float lonSpan, Integer radius, String query, Integer minResult, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/{dialect}/api/where/arrivals-and-departures-for-location"
            .replace("{" + "dialect" + "}", localVarApiClient.escapeString(dialect.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (groupLimit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("groupLimit", groupLimit));
        }

        if (clientLon != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("clientLon", clientLon));
        }

        if (clientLat != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("clientLat", clientLat));
        }

        if (minutesBefore != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minutesBefore", minutesBefore));
        }

        if (minutesAfter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minutesAfter", minutesAfter));
        }

        if (stopId != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "stopId", stopId));
        }

        if (includeRouteId != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "includeRouteId", includeRouteId));
        }

        if (time != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("time", time));
        }

        if (onlyDepartures != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("onlyDepartures", onlyDepartures));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (lat != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("lat", lat));
        }

        if (lon != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("lon", lon));
        }

        if (latSpan != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("latSpan", latSpan));
        }

        if (lonSpan != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("lonSpan", lonSpan));
        }

        if (radius != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("radius", radius));
        }

        if (query != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("query", query));
        }

        if (minResult != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minResult", minResult));
        }

        if (appVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("appVersion", appVersion));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("version", version));
        }

        if (includeReferences != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "includeReferences", includeReferences));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyQuery" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getArrivalsAndDeparturesForLocationValidateBeforeCall(Dialect dialect, Integer groupLimit, Double clientLon, Double clientLat, Integer minutesBefore, Integer minutesAfter, List<String> stopId, List<String> includeRouteId, Long time, Boolean onlyDepartures, Integer limit, Float lat, Float lon, Float latSpan, Float lonSpan, Integer radius, String query, Integer minResult, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'dialect' is set
        if (dialect == null) {
            throw new ApiException("Missing the required parameter 'dialect' when calling getArrivalsAndDeparturesForLocation(Async)");
        }

        return getArrivalsAndDeparturesForLocationCall(dialect, groupLimit, clientLon, clientLat, minutesBefore, minutesAfter, stopId, includeRouteId, time, onlyDepartures, limit, lat, lon, latSpan, lonSpan, radius, query, minResult, appVersion, version, includeReferences, _callback);

    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param groupLimit Menetrendi adatok maximális száma egy csoportban. (optional, default to 4)
     * @param clientLon A kliens hosszúsági koordinátája. (optional, default to 0)
     * @param clientLat A kliens szélességi koordinátája. (optional, default to 0)
     * @param minutesBefore A lekérdezési időablak a &#x60;time&#x60; paraméter előtt ennyi perccel indul. (optional, default to 2)
     * @param minutesAfter A lekérdezési időablak a &#x60;time&#x60; paraméter után ennyi perccel ér véget. (optional, default to 30)
     * @param stopId A megállók azonosítóinak listája, amelyekhez a lekérést végezzük. (optional)
     * @param includeRouteId A válasz szűrésére használt járatok azonosítóinak listája. (optional)
     * @param time A lekérdezés kiértékeléséhez használt időpont. Alapértelmezetten az aktuális szerveridő. (optional)
     * @param onlyDepartures Ha igaz akkor csak az érkezési (és előrejelzett érkezési) idők nem szerepelnek a válaszban. (optional, default to true)
     * @param limit A visszaadott indulási és érkezési idők listájának maximális hossza. (optional, default to 60)
     * @param lat A helyszín középpontjának szélessgéi koordinátája. (optional)
     * @param lon A helyszín középpontjának hosszúsági koordinátája. (optional)
     * @param latSpan A lekérési terület szélességi íve. (Terület szélessége: &#x60;lat +/- latspan&#x60;). (optional)
     * @param lonSpan A lekérési terület hosszúsági íve. (Terület hosszúsága: &#x60;lon +/- lonSpan&#x60;). (optional)
     * @param radius Ha a &#x60;latSpan&#x60; vagy a &#x60;longSpan&#x60; nincs kitöltve, a keresési terület a középpontól számított &#x60;radius&#x60; méter távolság mind a négy irányban. (optional, default to 100)
     * @param query A válasz szűrésére használt keresési kifejezés. (optional)
     * @param minResult A visszaadott elemek minimális száma. (optional, default to 5)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return ArrivalsAndDeparturesForLocationOTPMethodResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszaadja egy területhez tartozó érkezési és indulási időket járatazonosítók és célállomások szerint csoportosítva. </td><td>  -  </td></tr>
     </table>
     */
    public ArrivalsAndDeparturesForLocationOTPMethodResponse getArrivalsAndDeparturesForLocation(Dialect dialect, Integer groupLimit, Double clientLon, Double clientLat, Integer minutesBefore, Integer minutesAfter, List<String> stopId, List<String> includeRouteId, Long time, Boolean onlyDepartures, Integer limit, Float lat, Float lon, Float latSpan, Float lonSpan, Integer radius, String query, Integer minResult, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        ApiResponse<ArrivalsAndDeparturesForLocationOTPMethodResponse> localVarResp = getArrivalsAndDeparturesForLocationWithHttpInfo(dialect, groupLimit, clientLon, clientLat, minutesBefore, minutesAfter, stopId, includeRouteId, time, onlyDepartures, limit, lat, lon, latSpan, lonSpan, radius, query, minResult, appVersion, version, includeReferences);
        return localVarResp.getData();
    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param groupLimit Menetrendi adatok maximális száma egy csoportban. (optional, default to 4)
     * @param clientLon A kliens hosszúsági koordinátája. (optional, default to 0)
     * @param clientLat A kliens szélességi koordinátája. (optional, default to 0)
     * @param minutesBefore A lekérdezési időablak a &#x60;time&#x60; paraméter előtt ennyi perccel indul. (optional, default to 2)
     * @param minutesAfter A lekérdezési időablak a &#x60;time&#x60; paraméter után ennyi perccel ér véget. (optional, default to 30)
     * @param stopId A megállók azonosítóinak listája, amelyekhez a lekérést végezzük. (optional)
     * @param includeRouteId A válasz szűrésére használt járatok azonosítóinak listája. (optional)
     * @param time A lekérdezés kiértékeléséhez használt időpont. Alapértelmezetten az aktuális szerveridő. (optional)
     * @param onlyDepartures Ha igaz akkor csak az érkezési (és előrejelzett érkezési) idők nem szerepelnek a válaszban. (optional, default to true)
     * @param limit A visszaadott indulási és érkezési idők listájának maximális hossza. (optional, default to 60)
     * @param lat A helyszín középpontjának szélessgéi koordinátája. (optional)
     * @param lon A helyszín középpontjának hosszúsági koordinátája. (optional)
     * @param latSpan A lekérési terület szélességi íve. (Terület szélessége: &#x60;lat +/- latspan&#x60;). (optional)
     * @param lonSpan A lekérési terület hosszúsági íve. (Terület hosszúsága: &#x60;lon +/- lonSpan&#x60;). (optional)
     * @param radius Ha a &#x60;latSpan&#x60; vagy a &#x60;longSpan&#x60; nincs kitöltve, a keresési terület a középpontól számított &#x60;radius&#x60; méter távolság mind a négy irányban. (optional, default to 100)
     * @param query A válasz szűrésére használt keresési kifejezés. (optional)
     * @param minResult A visszaadott elemek minimális száma. (optional, default to 5)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return ApiResponse&lt;ArrivalsAndDeparturesForLocationOTPMethodResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszaadja egy területhez tartozó érkezési és indulási időket járatazonosítók és célállomások szerint csoportosítva. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ArrivalsAndDeparturesForLocationOTPMethodResponse> getArrivalsAndDeparturesForLocationWithHttpInfo(Dialect dialect, Integer groupLimit, Double clientLon, Double clientLat, Integer minutesBefore, Integer minutesAfter, List<String> stopId, List<String> includeRouteId, Long time, Boolean onlyDepartures, Integer limit, Float lat, Float lon, Float latSpan, Float lonSpan, Integer radius, String query, Integer minResult, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        okhttp3.Call localVarCall = getArrivalsAndDeparturesForLocationValidateBeforeCall(dialect, groupLimit, clientLon, clientLat, minutesBefore, minutesAfter, stopId, includeRouteId, time, onlyDepartures, limit, lat, lon, latSpan, lonSpan, radius, query, minResult, appVersion, version, includeReferences, null);
        Type localVarReturnType = new TypeToken<ArrivalsAndDeparturesForLocationOTPMethodResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param groupLimit Menetrendi adatok maximális száma egy csoportban. (optional, default to 4)
     * @param clientLon A kliens hosszúsági koordinátája. (optional, default to 0)
     * @param clientLat A kliens szélességi koordinátája. (optional, default to 0)
     * @param minutesBefore A lekérdezési időablak a &#x60;time&#x60; paraméter előtt ennyi perccel indul. (optional, default to 2)
     * @param minutesAfter A lekérdezési időablak a &#x60;time&#x60; paraméter után ennyi perccel ér véget. (optional, default to 30)
     * @param stopId A megállók azonosítóinak listája, amelyekhez a lekérést végezzük. (optional)
     * @param includeRouteId A válasz szűrésére használt járatok azonosítóinak listája. (optional)
     * @param time A lekérdezés kiértékeléséhez használt időpont. Alapértelmezetten az aktuális szerveridő. (optional)
     * @param onlyDepartures Ha igaz akkor csak az érkezési (és előrejelzett érkezési) idők nem szerepelnek a válaszban. (optional, default to true)
     * @param limit A visszaadott indulási és érkezési idők listájának maximális hossza. (optional, default to 60)
     * @param lat A helyszín középpontjának szélessgéi koordinátája. (optional)
     * @param lon A helyszín középpontjának hosszúsági koordinátája. (optional)
     * @param latSpan A lekérési terület szélességi íve. (Terület szélessége: &#x60;lat +/- latspan&#x60;). (optional)
     * @param lonSpan A lekérési terület hosszúsági íve. (Terület hosszúsága: &#x60;lon +/- lonSpan&#x60;). (optional)
     * @param radius Ha a &#x60;latSpan&#x60; vagy a &#x60;longSpan&#x60; nincs kitöltve, a keresési terület a középpontól számított &#x60;radius&#x60; méter távolság mind a négy irányban. (optional, default to 100)
     * @param query A válasz szűrésére használt keresési kifejezés. (optional)
     * @param minResult A visszaadott elemek minimális száma. (optional, default to 5)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszaadja egy területhez tartozó érkezési és indulási időket járatazonosítók és célállomások szerint csoportosítva. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getArrivalsAndDeparturesForLocationAsync(Dialect dialect, Integer groupLimit, Double clientLon, Double clientLat, Integer minutesBefore, Integer minutesAfter, List<String> stopId, List<String> includeRouteId, Long time, Boolean onlyDepartures, Integer limit, Float lat, Float lon, Float latSpan, Float lonSpan, Integer radius, String query, Integer minResult, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback<ArrivalsAndDeparturesForLocationOTPMethodResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getArrivalsAndDeparturesForLocationValidateBeforeCall(dialect, groupLimit, clientLon, clientLat, minutesBefore, minutesAfter, stopId, includeRouteId, time, onlyDepartures, limit, lat, lon, latSpan, lonSpan, radius, query, minResult, appVersion, version, includeReferences, _callback);
        Type localVarReturnType = new TypeToken<ArrivalsAndDeparturesForLocationOTPMethodResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getArrivalsAndDeparturesForStop
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param minutesBefore A lekérdezési időablak a &#x60;time&#x60; paraméter előtt ennyi perccel indul. (optional, default to 2)
     * @param minutesAfter A lekérdezési időablak a &#x60;time&#x60; paraméter után ennyi perccel ér véget. (optional, default to 30)
     * @param stopId A megállók azonosítóinak listája, amelyekhez a lekérést végezzük. (optional)
     * @param includeRouteId A válasz szűrésére használt járatok azonosítóinak listája. (optional)
     * @param time A lekérdezés kiértékeléséhez használt időpont. Alapértelmezetten az aktuális szerveridő. (optional)
     * @param onlyDepartures Ha igaz akkor csak az érkezési (és előrejelzett érkezési) idők nem szerepelnek a válaszban. (optional, default to true)
     * @param limit A visszaadott indulási és érkezési idők listájának maximális hossza. (optional, default to 60)
     * @param lat A helyszín középpontjának szélessgéi koordinátája. (optional)
     * @param lon A helyszín középpontjának hosszúsági koordinátája. (optional)
     * @param latSpan A lekérési terület szélességi íve. (Terület szélessége: &#x60;lat +/- latspan&#x60;). (optional)
     * @param lonSpan A lekérési terület hosszúsági íve. (Terület hosszúsága: &#x60;lon +/- lonSpan&#x60;). (optional)
     * @param radius Ha a &#x60;latSpan&#x60; vagy a &#x60;longSpan&#x60; nincs kitöltve, a keresési terület a középpontól számított &#x60;radius&#x60; méter távolság mind a négy irányban. (optional, default to 100)
     * @param query A válasz szűrésére használt keresési kifejezés. (optional)
     * @param minResult A visszaadott elemek minimális száma. (optional, default to 5)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Lekéri a megállóhoz tartozó érkezési és indulási időket. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getArrivalsAndDeparturesForStopCall(Dialect dialect, Integer minutesBefore, Integer minutesAfter, List<String> stopId, List<String> includeRouteId, Long time, Boolean onlyDepartures, Integer limit, Float lat, Float lon, Float latSpan, Float lonSpan, Integer radius, String query, Integer minResult, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/{dialect}/api/where/arrivals-and-departures-for-stop"
            .replace("{" + "dialect" + "}", localVarApiClient.escapeString(dialect.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (minutesBefore != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minutesBefore", minutesBefore));
        }

        if (minutesAfter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minutesAfter", minutesAfter));
        }

        if (stopId != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "stopId", stopId));
        }

        if (includeRouteId != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "includeRouteId", includeRouteId));
        }

        if (time != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("time", time));
        }

        if (onlyDepartures != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("onlyDepartures", onlyDepartures));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (lat != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("lat", lat));
        }

        if (lon != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("lon", lon));
        }

        if (latSpan != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("latSpan", latSpan));
        }

        if (lonSpan != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("lonSpan", lonSpan));
        }

        if (radius != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("radius", radius));
        }

        if (query != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("query", query));
        }

        if (minResult != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minResult", minResult));
        }

        if (appVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("appVersion", appVersion));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("version", version));
        }

        if (includeReferences != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "includeReferences", includeReferences));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyQuery" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getArrivalsAndDeparturesForStopValidateBeforeCall(Dialect dialect, Integer minutesBefore, Integer minutesAfter, List<String> stopId, List<String> includeRouteId, Long time, Boolean onlyDepartures, Integer limit, Float lat, Float lon, Float latSpan, Float lonSpan, Integer radius, String query, Integer minResult, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'dialect' is set
        if (dialect == null) {
            throw new ApiException("Missing the required parameter 'dialect' when calling getArrivalsAndDeparturesForStop(Async)");
        }

        return getArrivalsAndDeparturesForStopCall(dialect, minutesBefore, minutesAfter, stopId, includeRouteId, time, onlyDepartures, limit, lat, lon, latSpan, lonSpan, radius, query, minResult, appVersion, version, includeReferences, _callback);

    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param minutesBefore A lekérdezési időablak a &#x60;time&#x60; paraméter előtt ennyi perccel indul. (optional, default to 2)
     * @param minutesAfter A lekérdezési időablak a &#x60;time&#x60; paraméter után ennyi perccel ér véget. (optional, default to 30)
     * @param stopId A megállók azonosítóinak listája, amelyekhez a lekérést végezzük. (optional)
     * @param includeRouteId A válasz szűrésére használt járatok azonosítóinak listája. (optional)
     * @param time A lekérdezés kiértékeléséhez használt időpont. Alapértelmezetten az aktuális szerveridő. (optional)
     * @param onlyDepartures Ha igaz akkor csak az érkezési (és előrejelzett érkezési) idők nem szerepelnek a válaszban. (optional, default to true)
     * @param limit A visszaadott indulási és érkezési idők listájának maximális hossza. (optional, default to 60)
     * @param lat A helyszín középpontjának szélessgéi koordinátája. (optional)
     * @param lon A helyszín középpontjának hosszúsági koordinátája. (optional)
     * @param latSpan A lekérési terület szélességi íve. (Terület szélessége: &#x60;lat +/- latspan&#x60;). (optional)
     * @param lonSpan A lekérési terület hosszúsági íve. (Terület hosszúsága: &#x60;lon +/- lonSpan&#x60;). (optional)
     * @param radius Ha a &#x60;latSpan&#x60; vagy a &#x60;longSpan&#x60; nincs kitöltve, a keresési terület a középpontól számított &#x60;radius&#x60; méter távolság mind a négy irányban. (optional, default to 100)
     * @param query A válasz szűrésére használt keresési kifejezés. (optional)
     * @param minResult A visszaadott elemek minimális száma. (optional, default to 5)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return ArrivalsAndDeparturesForStopOTPMethodResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Lekéri a megállóhoz tartozó érkezési és indulási időket. </td><td>  -  </td></tr>
     </table>
     */
    public ArrivalsAndDeparturesForStopOTPMethodResponse getArrivalsAndDeparturesForStop(Dialect dialect, Integer minutesBefore, Integer minutesAfter, List<String> stopId, List<String> includeRouteId, Long time, Boolean onlyDepartures, Integer limit, Float lat, Float lon, Float latSpan, Float lonSpan, Integer radius, String query, Integer minResult, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        ApiResponse<ArrivalsAndDeparturesForStopOTPMethodResponse> localVarResp = getArrivalsAndDeparturesForStopWithHttpInfo(dialect, minutesBefore, minutesAfter, stopId, includeRouteId, time, onlyDepartures, limit, lat, lon, latSpan, lonSpan, radius, query, minResult, appVersion, version, includeReferences);
        return localVarResp.getData();
    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param minutesBefore A lekérdezési időablak a &#x60;time&#x60; paraméter előtt ennyi perccel indul. (optional, default to 2)
     * @param minutesAfter A lekérdezési időablak a &#x60;time&#x60; paraméter után ennyi perccel ér véget. (optional, default to 30)
     * @param stopId A megállók azonosítóinak listája, amelyekhez a lekérést végezzük. (optional)
     * @param includeRouteId A válasz szűrésére használt járatok azonosítóinak listája. (optional)
     * @param time A lekérdezés kiértékeléséhez használt időpont. Alapértelmezetten az aktuális szerveridő. (optional)
     * @param onlyDepartures Ha igaz akkor csak az érkezési (és előrejelzett érkezési) idők nem szerepelnek a válaszban. (optional, default to true)
     * @param limit A visszaadott indulási és érkezési idők listájának maximális hossza. (optional, default to 60)
     * @param lat A helyszín középpontjának szélessgéi koordinátája. (optional)
     * @param lon A helyszín középpontjának hosszúsági koordinátája. (optional)
     * @param latSpan A lekérési terület szélességi íve. (Terület szélessége: &#x60;lat +/- latspan&#x60;). (optional)
     * @param lonSpan A lekérési terület hosszúsági íve. (Terület hosszúsága: &#x60;lon +/- lonSpan&#x60;). (optional)
     * @param radius Ha a &#x60;latSpan&#x60; vagy a &#x60;longSpan&#x60; nincs kitöltve, a keresési terület a középpontól számított &#x60;radius&#x60; méter távolság mind a négy irányban. (optional, default to 100)
     * @param query A válasz szűrésére használt keresési kifejezés. (optional)
     * @param minResult A visszaadott elemek minimális száma. (optional, default to 5)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return ApiResponse&lt;ArrivalsAndDeparturesForStopOTPMethodResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Lekéri a megállóhoz tartozó érkezési és indulási időket. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ArrivalsAndDeparturesForStopOTPMethodResponse> getArrivalsAndDeparturesForStopWithHttpInfo(Dialect dialect, Integer minutesBefore, Integer minutesAfter, List<String> stopId, List<String> includeRouteId, Long time, Boolean onlyDepartures, Integer limit, Float lat, Float lon, Float latSpan, Float lonSpan, Integer radius, String query, Integer minResult, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        okhttp3.Call localVarCall = getArrivalsAndDeparturesForStopValidateBeforeCall(dialect, minutesBefore, minutesAfter, stopId, includeRouteId, time, onlyDepartures, limit, lat, lon, latSpan, lonSpan, radius, query, minResult, appVersion, version, includeReferences, null);
        Type localVarReturnType = new TypeToken<ArrivalsAndDeparturesForStopOTPMethodResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param minutesBefore A lekérdezési időablak a &#x60;time&#x60; paraméter előtt ennyi perccel indul. (optional, default to 2)
     * @param minutesAfter A lekérdezési időablak a &#x60;time&#x60; paraméter után ennyi perccel ér véget. (optional, default to 30)
     * @param stopId A megállók azonosítóinak listája, amelyekhez a lekérést végezzük. (optional)
     * @param includeRouteId A válasz szűrésére használt járatok azonosítóinak listája. (optional)
     * @param time A lekérdezés kiértékeléséhez használt időpont. Alapértelmezetten az aktuális szerveridő. (optional)
     * @param onlyDepartures Ha igaz akkor csak az érkezési (és előrejelzett érkezési) idők nem szerepelnek a válaszban. (optional, default to true)
     * @param limit A visszaadott indulási és érkezési idők listájának maximális hossza. (optional, default to 60)
     * @param lat A helyszín középpontjának szélessgéi koordinátája. (optional)
     * @param lon A helyszín középpontjának hosszúsági koordinátája. (optional)
     * @param latSpan A lekérési terület szélességi íve. (Terület szélessége: &#x60;lat +/- latspan&#x60;). (optional)
     * @param lonSpan A lekérési terület hosszúsági íve. (Terület hosszúsága: &#x60;lon +/- lonSpan&#x60;). (optional)
     * @param radius Ha a &#x60;latSpan&#x60; vagy a &#x60;longSpan&#x60; nincs kitöltve, a keresési terület a középpontól számított &#x60;radius&#x60; méter távolság mind a négy irányban. (optional, default to 100)
     * @param query A válasz szűrésére használt keresési kifejezés. (optional)
     * @param minResult A visszaadott elemek minimális száma. (optional, default to 5)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Lekéri a megállóhoz tartozó érkezési és indulási időket. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getArrivalsAndDeparturesForStopAsync(Dialect dialect, Integer minutesBefore, Integer minutesAfter, List<String> stopId, List<String> includeRouteId, Long time, Boolean onlyDepartures, Integer limit, Float lat, Float lon, Float latSpan, Float lonSpan, Integer radius, String query, Integer minResult, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback<ArrivalsAndDeparturesForStopOTPMethodResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getArrivalsAndDeparturesForStopValidateBeforeCall(dialect, minutesBefore, minutesAfter, stopId, includeRouteId, time, onlyDepartures, limit, lat, lon, latSpan, lonSpan, radius, query, minResult, appVersion, version, includeReferences, _callback);
        Type localVarReturnType = new TypeToken<ArrivalsAndDeparturesForStopOTPMethodResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getBicycleRentalStations
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszatér az összes kerékpárkölcsönző állomással. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getBicycleRentalStationsCall(Dialect dialect, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/{dialect}/api/where/bicycle-rental"
            .replace("{" + "dialect" + "}", localVarApiClient.escapeString(dialect.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (appVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("appVersion", appVersion));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("version", version));
        }

        if (includeReferences != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "includeReferences", includeReferences));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyQuery" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getBicycleRentalStationsValidateBeforeCall(Dialect dialect, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'dialect' is set
        if (dialect == null) {
            throw new ApiException("Missing the required parameter 'dialect' when calling getBicycleRentalStations(Async)");
        }

        return getBicycleRentalStationsCall(dialect, appVersion, version, includeReferences, _callback);

    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return BicycleRentalMethodResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszatér az összes kerékpárkölcsönző állomással. </td><td>  -  </td></tr>
     </table>
     */
    public BicycleRentalMethodResponse getBicycleRentalStations(Dialect dialect, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        ApiResponse<BicycleRentalMethodResponse> localVarResp = getBicycleRentalStationsWithHttpInfo(dialect, appVersion, version, includeReferences);
        return localVarResp.getData();
    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return ApiResponse&lt;BicycleRentalMethodResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszatér az összes kerékpárkölcsönző állomással. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BicycleRentalMethodResponse> getBicycleRentalStationsWithHttpInfo(Dialect dialect, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        okhttp3.Call localVarCall = getBicycleRentalStationsValidateBeforeCall(dialect, appVersion, version, includeReferences, null);
        Type localVarReturnType = new TypeToken<BicycleRentalMethodResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszatér az összes kerékpárkölcsönző állomással. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getBicycleRentalStationsAsync(Dialect dialect, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback<BicycleRentalMethodResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getBicycleRentalStationsValidateBeforeCall(dialect, appVersion, version, includeReferences, _callback);
        Type localVarReturnType = new TypeToken<BicycleRentalMethodResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getMetadata
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param time A lekérés kiértékelésének időpontja epoch másodpercben (az aktív zavarok lekéréséhez szükséges).A szerver ideje az alapértelmezett értéke. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A szerver metaadataival tér vissza. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMetadataCall(Dialect dialect, Long time, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/{dialect}/api/where/metadata"
            .replace("{" + "dialect" + "}", localVarApiClient.escapeString(dialect.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (time != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("time", time));
        }

        if (appVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("appVersion", appVersion));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("version", version));
        }

        if (includeReferences != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "includeReferences", includeReferences));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyQuery" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getMetadataValidateBeforeCall(Dialect dialect, Long time, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'dialect' is set
        if (dialect == null) {
            throw new ApiException("Missing the required parameter 'dialect' when calling getMetadata(Async)");
        }

        return getMetadataCall(dialect, time, appVersion, version, includeReferences, _callback);

    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param time A lekérés kiértékelésének időpontja epoch másodpercben (az aktív zavarok lekéréséhez szükséges).A szerver ideje az alapértelmezett értéke. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return MetadataResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A szerver metaadataival tér vissza. </td><td>  -  </td></tr>
     </table>
     */
    public MetadataResponse getMetadata(Dialect dialect, Long time, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        ApiResponse<MetadataResponse> localVarResp = getMetadataWithHttpInfo(dialect, time, appVersion, version, includeReferences);
        return localVarResp.getData();
    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param time A lekérés kiértékelésének időpontja epoch másodpercben (az aktív zavarok lekéréséhez szükséges).A szerver ideje az alapértelmezett értéke. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return ApiResponse&lt;MetadataResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A szerver metaadataival tér vissza. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<MetadataResponse> getMetadataWithHttpInfo(Dialect dialect, Long time, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        okhttp3.Call localVarCall = getMetadataValidateBeforeCall(dialect, time, appVersion, version, includeReferences, null);
        Type localVarReturnType = new TypeToken<MetadataResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param time A lekérés kiértékelésének időpontja epoch másodpercben (az aktív zavarok lekéréséhez szükséges).A szerver ideje az alapértelmezett értéke. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A szerver metaadataival tér vissza. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMetadataAsync(Dialect dialect, Long time, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback<MetadataResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getMetadataValidateBeforeCall(dialect, time, appVersion, version, includeReferences, _callback);
        Type localVarReturnType = new TypeToken<MetadataResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getMultiRouteDetails
     * @param routeId A lekért járatok azonosítói. (required)
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param date Az aktív zavarok lekéréséhez használt dátum. Alapértelmezett értéke az aktuális nap. (optional)
     * @param related Ha igaz, akkor az útvonalhoz tartozó kapcsolódó útvonalak is szerepelnek a válaszban. (optional, default to false)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Az összes járatot visszaadja a megadott azonosítókhoz. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> A &#x60;date&#x60; paramétert nem sikerült beolvasni. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Ismeretlen járat azonosító. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMultiRouteDetailsCall(List<String> routeId, Dialect dialect, String date, Boolean related, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/{dialect}/api/where/multi-route-details"
            .replace("{" + "dialect" + "}", localVarApiClient.escapeString(dialect.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (routeId != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "routeId", routeId));
        }

        if (date != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("date", date));
        }

        if (related != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("related", related));
        }

        if (appVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("appVersion", appVersion));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("version", version));
        }

        if (includeReferences != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "includeReferences", includeReferences));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyQuery" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getMultiRouteDetailsValidateBeforeCall(List<String> routeId, Dialect dialect, String date, Boolean related, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'routeId' is set
        if (routeId == null) {
            throw new ApiException("Missing the required parameter 'routeId' when calling getMultiRouteDetails(Async)");
        }

        // verify the required parameter 'dialect' is set
        if (dialect == null) {
            throw new ApiException("Missing the required parameter 'dialect' when calling getMultiRouteDetails(Async)");
        }

        return getMultiRouteDetailsCall(routeId, dialect, date, related, appVersion, version, includeReferences, _callback);

    }

    /**
     * 
     * 
     * @param routeId A lekért járatok azonosítói. (required)
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param date Az aktív zavarok lekéréséhez használt dátum. Alapértelmezett értéke az aktuális nap. (optional)
     * @param related Ha igaz, akkor az útvonalhoz tartozó kapcsolódó útvonalak is szerepelnek a válaszban. (optional, default to false)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return MultiRouteDetailsMethodResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Az összes járatot visszaadja a megadott azonosítókhoz. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> A &#x60;date&#x60; paramétert nem sikerült beolvasni. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Ismeretlen járat azonosító. </td><td>  -  </td></tr>
     </table>
     */
    public MultiRouteDetailsMethodResponse getMultiRouteDetails(List<String> routeId, Dialect dialect, String date, Boolean related, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        ApiResponse<MultiRouteDetailsMethodResponse> localVarResp = getMultiRouteDetailsWithHttpInfo(routeId, dialect, date, related, appVersion, version, includeReferences);
        return localVarResp.getData();
    }

    /**
     * 
     * 
     * @param routeId A lekért járatok azonosítói. (required)
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param date Az aktív zavarok lekéréséhez használt dátum. Alapértelmezett értéke az aktuális nap. (optional)
     * @param related Ha igaz, akkor az útvonalhoz tartozó kapcsolódó útvonalak is szerepelnek a válaszban. (optional, default to false)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return ApiResponse&lt;MultiRouteDetailsMethodResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Az összes járatot visszaadja a megadott azonosítókhoz. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> A &#x60;date&#x60; paramétert nem sikerült beolvasni. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Ismeretlen járat azonosító. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<MultiRouteDetailsMethodResponse> getMultiRouteDetailsWithHttpInfo(List<String> routeId, Dialect dialect, String date, Boolean related, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        okhttp3.Call localVarCall = getMultiRouteDetailsValidateBeforeCall(routeId, dialect, date, related, appVersion, version, includeReferences, null);
        Type localVarReturnType = new TypeToken<MultiRouteDetailsMethodResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param routeId A lekért járatok azonosítói. (required)
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param date Az aktív zavarok lekéréséhez használt dátum. Alapértelmezett értéke az aktuális nap. (optional)
     * @param related Ha igaz, akkor az útvonalhoz tartozó kapcsolódó útvonalak is szerepelnek a válaszban. (optional, default to false)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Az összes járatot visszaadja a megadott azonosítókhoz. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> A &#x60;date&#x60; paramétert nem sikerült beolvasni. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Ismeretlen járat azonosító. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMultiRouteDetailsAsync(List<String> routeId, Dialect dialect, String date, Boolean related, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback<MultiRouteDetailsMethodResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getMultiRouteDetailsValidateBeforeCall(routeId, dialect, date, related, appVersion, version, includeReferences, _callback);
        Type localVarReturnType = new TypeToken<MultiRouteDetailsMethodResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getReferences
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param agencyId A szolgáltató ID-je. (optional)
     * @param alertId A zavar ID-je. (optional)
     * @param routeId A járat ID-ja. (optional)
     * @param stopId A megálló ID-ja. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> ID alapú referencia lekérdezés. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getReferencesCall(Dialect dialect, List<String> agencyId, List<String> alertId, List<String> routeId, List<String> stopId, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/{dialect}/api/where/references"
            .replace("{" + "dialect" + "}", localVarApiClient.escapeString(dialect.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (agencyId != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "agencyId", agencyId));
        }

        if (alertId != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "alertId", alertId));
        }

        if (routeId != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "routeId", routeId));
        }

        if (stopId != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "stopId", stopId));
        }

        if (appVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("appVersion", appVersion));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("version", version));
        }

        if (includeReferences != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "includeReferences", includeReferences));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyQuery" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getReferencesValidateBeforeCall(Dialect dialect, List<String> agencyId, List<String> alertId, List<String> routeId, List<String> stopId, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'dialect' is set
        if (dialect == null) {
            throw new ApiException("Missing the required parameter 'dialect' when calling getReferences(Async)");
        }

        return getReferencesCall(dialect, agencyId, alertId, routeId, stopId, appVersion, version, includeReferences, _callback);

    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param agencyId A szolgáltató ID-je. (optional)
     * @param alertId A zavar ID-je. (optional)
     * @param routeId A járat ID-ja. (optional)
     * @param stopId A megálló ID-ja. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return ReferencesMethodResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> ID alapú referencia lekérdezés. </td><td>  -  </td></tr>
     </table>
     */
    public ReferencesMethodResponse getReferences(Dialect dialect, List<String> agencyId, List<String> alertId, List<String> routeId, List<String> stopId, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        ApiResponse<ReferencesMethodResponse> localVarResp = getReferencesWithHttpInfo(dialect, agencyId, alertId, routeId, stopId, appVersion, version, includeReferences);
        return localVarResp.getData();
    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param agencyId A szolgáltató ID-je. (optional)
     * @param alertId A zavar ID-je. (optional)
     * @param routeId A járat ID-ja. (optional)
     * @param stopId A megálló ID-ja. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return ApiResponse&lt;ReferencesMethodResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> ID alapú referencia lekérdezés. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ReferencesMethodResponse> getReferencesWithHttpInfo(Dialect dialect, List<String> agencyId, List<String> alertId, List<String> routeId, List<String> stopId, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        okhttp3.Call localVarCall = getReferencesValidateBeforeCall(dialect, agencyId, alertId, routeId, stopId, appVersion, version, includeReferences, null);
        Type localVarReturnType = new TypeToken<ReferencesMethodResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param agencyId A szolgáltató ID-je. (optional)
     * @param alertId A zavar ID-je. (optional)
     * @param routeId A járat ID-ja. (optional)
     * @param stopId A megálló ID-ja. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> ID alapú referencia lekérdezés. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getReferencesAsync(Dialect dialect, List<String> agencyId, List<String> alertId, List<String> routeId, List<String> stopId, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback<ReferencesMethodResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getReferencesValidateBeforeCall(dialect, agencyId, alertId, routeId, stopId, appVersion, version, includeReferences, _callback);
        Type localVarReturnType = new TypeToken<ReferencesMethodResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getRouteDetails
     * @param routeId A járat ID-ja. (required)
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param date Az aktív zavarok lekéréséhez használt dátum. Alapértelmezett értéke az aktuális nap. (optional)
     * @param related Ha igaz, akkor az útvonalhoz tartozó kapcsolódó útvonalak is szerepelnek a válaszban. (optional, default to false)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszaadja a megadott ID-val rendelkező járatot. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Rossz formátumú a &#x60;date&#x60; paraméter. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Az ID-hoz nem található járat. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRouteDetailsCall(String routeId, Dialect dialect, String date, Boolean related, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/{dialect}/api/where/route-details"
            .replace("{" + "dialect" + "}", localVarApiClient.escapeString(dialect.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (routeId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("routeId", routeId));
        }

        if (date != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("date", date));
        }

        if (related != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("related", related));
        }

        if (appVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("appVersion", appVersion));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("version", version));
        }

        if (includeReferences != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "includeReferences", includeReferences));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyQuery" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getRouteDetailsValidateBeforeCall(String routeId, Dialect dialect, String date, Boolean related, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'routeId' is set
        if (routeId == null) {
            throw new ApiException("Missing the required parameter 'routeId' when calling getRouteDetails(Async)");
        }

        // verify the required parameter 'dialect' is set
        if (dialect == null) {
            throw new ApiException("Missing the required parameter 'dialect' when calling getRouteDetails(Async)");
        }

        return getRouteDetailsCall(routeId, dialect, date, related, appVersion, version, includeReferences, _callback);

    }

    /**
     * 
     * 
     * @param routeId A járat ID-ja. (required)
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param date Az aktív zavarok lekéréséhez használt dátum. Alapértelmezett értéke az aktuális nap. (optional)
     * @param related Ha igaz, akkor az útvonalhoz tartozó kapcsolódó útvonalak is szerepelnek a válaszban. (optional, default to false)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return RouteDetailsMethodResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszaadja a megadott ID-val rendelkező járatot. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Rossz formátumú a &#x60;date&#x60; paraméter. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Az ID-hoz nem található járat. </td><td>  -  </td></tr>
     </table>
     */
    public RouteDetailsMethodResponse getRouteDetails(String routeId, Dialect dialect, String date, Boolean related, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        ApiResponse<RouteDetailsMethodResponse> localVarResp = getRouteDetailsWithHttpInfo(routeId, dialect, date, related, appVersion, version, includeReferences);
        return localVarResp.getData();
    }

    /**
     * 
     * 
     * @param routeId A járat ID-ja. (required)
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param date Az aktív zavarok lekéréséhez használt dátum. Alapértelmezett értéke az aktuális nap. (optional)
     * @param related Ha igaz, akkor az útvonalhoz tartozó kapcsolódó útvonalak is szerepelnek a válaszban. (optional, default to false)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return ApiResponse&lt;RouteDetailsMethodResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszaadja a megadott ID-val rendelkező járatot. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Rossz formátumú a &#x60;date&#x60; paraméter. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Az ID-hoz nem található járat. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RouteDetailsMethodResponse> getRouteDetailsWithHttpInfo(String routeId, Dialect dialect, String date, Boolean related, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        okhttp3.Call localVarCall = getRouteDetailsValidateBeforeCall(routeId, dialect, date, related, appVersion, version, includeReferences, null);
        Type localVarReturnType = new TypeToken<RouteDetailsMethodResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param routeId A járat ID-ja. (required)
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param date Az aktív zavarok lekéréséhez használt dátum. Alapértelmezett értéke az aktuális nap. (optional)
     * @param related Ha igaz, akkor az útvonalhoz tartozó kapcsolódó útvonalak is szerepelnek a válaszban. (optional, default to false)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszaadja a megadott ID-val rendelkező járatot. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Rossz formátumú a &#x60;date&#x60; paraméter. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Az ID-hoz nem található járat. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRouteDetailsAsync(String routeId, Dialect dialect, String date, Boolean related, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback<RouteDetailsMethodResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getRouteDetailsValidateBeforeCall(routeId, dialect, date, related, appVersion, version, includeReferences, _callback);
        Type localVarReturnType = new TypeToken<RouteDetailsMethodResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getRouteDetailsForStop
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param stopId A lekért megálló azonosítója. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A megállóhoz és a testvérmegállóihoz tartozó összes járattal tér vissza. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Ismeretlen megálló azonosító. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRouteDetailsForStopCall(Dialect dialect, String stopId, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/{dialect}/api/where/route-details-for-stop"
            .replace("{" + "dialect" + "}", localVarApiClient.escapeString(dialect.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (stopId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("stopId", stopId));
        }

        if (appVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("appVersion", appVersion));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("version", version));
        }

        if (includeReferences != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "includeReferences", includeReferences));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyQuery" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getRouteDetailsForStopValidateBeforeCall(Dialect dialect, String stopId, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'dialect' is set
        if (dialect == null) {
            throw new ApiException("Missing the required parameter 'dialect' when calling getRouteDetailsForStop(Async)");
        }

        return getRouteDetailsForStopCall(dialect, stopId, appVersion, version, includeReferences, _callback);

    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param stopId A lekért megálló azonosítója. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return RouteDetailsForStopMethodResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A megállóhoz és a testvérmegállóihoz tartozó összes járattal tér vissza. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Ismeretlen megálló azonosító. </td><td>  -  </td></tr>
     </table>
     */
    public RouteDetailsForStopMethodResponse getRouteDetailsForStop(Dialect dialect, String stopId, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        ApiResponse<RouteDetailsForStopMethodResponse> localVarResp = getRouteDetailsForStopWithHttpInfo(dialect, stopId, appVersion, version, includeReferences);
        return localVarResp.getData();
    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param stopId A lekért megálló azonosítója. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return ApiResponse&lt;RouteDetailsForStopMethodResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A megállóhoz és a testvérmegállóihoz tartozó összes járattal tér vissza. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Ismeretlen megálló azonosító. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RouteDetailsForStopMethodResponse> getRouteDetailsForStopWithHttpInfo(Dialect dialect, String stopId, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        okhttp3.Call localVarCall = getRouteDetailsForStopValidateBeforeCall(dialect, stopId, appVersion, version, includeReferences, null);
        Type localVarReturnType = new TypeToken<RouteDetailsForStopMethodResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param stopId A lekért megálló azonosítója. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A megállóhoz és a testvérmegállóihoz tartozó összes járattal tér vissza. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Ismeretlen megálló azonosító. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRouteDetailsForStopAsync(Dialect dialect, String stopId, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback<RouteDetailsForStopMethodResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getRouteDetailsForStopValidateBeforeCall(dialect, stopId, appVersion, version, includeReferences, _callback);
        Type localVarReturnType = new TypeToken<RouteDetailsForStopMethodResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getScheduleForStop
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param stopId A releváns megállók azonosítói. (optional)
     * @param date A kért dátum. (optional)
     * @param onlyDepartures Igaz esetén az érkezési és előrejelzett érkezési idők ki lesznek hagyva a válaszból. (optional, default to true)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszaadja a menetrendet az adott megállóhoz. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Nem sikerült beolvasni a dátumot. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Ismeretlen stopId. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getScheduleForStopCall(Dialect dialect, List<String> stopId, String date, Boolean onlyDepartures, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/{dialect}/api/where/schedule-for-stop"
            .replace("{" + "dialect" + "}", localVarApiClient.escapeString(dialect.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (stopId != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "stopId", stopId));
        }

        if (date != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("date", date));
        }

        if (onlyDepartures != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("onlyDepartures", onlyDepartures));
        }

        if (appVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("appVersion", appVersion));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("version", version));
        }

        if (includeReferences != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "includeReferences", includeReferences));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyQuery" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getScheduleForStopValidateBeforeCall(Dialect dialect, List<String> stopId, String date, Boolean onlyDepartures, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'dialect' is set
        if (dialect == null) {
            throw new ApiException("Missing the required parameter 'dialect' when calling getScheduleForStop(Async)");
        }

        return getScheduleForStopCall(dialect, stopId, date, onlyDepartures, appVersion, version, includeReferences, _callback);

    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param stopId A releváns megállók azonosítói. (optional)
     * @param date A kért dátum. (optional)
     * @param onlyDepartures Igaz esetén az érkezési és előrejelzett érkezési idők ki lesznek hagyva a válaszból. (optional, default to true)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return ScheduleForStopOTPMethodResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszaadja a menetrendet az adott megállóhoz. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Nem sikerült beolvasni a dátumot. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Ismeretlen stopId. </td><td>  -  </td></tr>
     </table>
     */
    public ScheduleForStopOTPMethodResponse getScheduleForStop(Dialect dialect, List<String> stopId, String date, Boolean onlyDepartures, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        ApiResponse<ScheduleForStopOTPMethodResponse> localVarResp = getScheduleForStopWithHttpInfo(dialect, stopId, date, onlyDepartures, appVersion, version, includeReferences);
        return localVarResp.getData();
    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param stopId A releváns megállók azonosítói. (optional)
     * @param date A kért dátum. (optional)
     * @param onlyDepartures Igaz esetén az érkezési és előrejelzett érkezési idők ki lesznek hagyva a válaszból. (optional, default to true)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return ApiResponse&lt;ScheduleForStopOTPMethodResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszaadja a menetrendet az adott megállóhoz. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Nem sikerült beolvasni a dátumot. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Ismeretlen stopId. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ScheduleForStopOTPMethodResponse> getScheduleForStopWithHttpInfo(Dialect dialect, List<String> stopId, String date, Boolean onlyDepartures, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        okhttp3.Call localVarCall = getScheduleForStopValidateBeforeCall(dialect, stopId, date, onlyDepartures, appVersion, version, includeReferences, null);
        Type localVarReturnType = new TypeToken<ScheduleForStopOTPMethodResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param stopId A releváns megállók azonosítói. (optional)
     * @param date A kért dátum. (optional)
     * @param onlyDepartures Igaz esetén az érkezési és előrejelzett érkezési idők ki lesznek hagyva a válaszból. (optional, default to true)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszaadja a menetrendet az adott megállóhoz. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Nem sikerült beolvasni a dátumot. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Ismeretlen stopId. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getScheduleForStopAsync(Dialect dialect, List<String> stopId, String date, Boolean onlyDepartures, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback<ScheduleForStopOTPMethodResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getScheduleForStopValidateBeforeCall(dialect, stopId, date, onlyDepartures, appVersion, version, includeReferences, _callback);
        Type localVarReturnType = new TypeToken<ScheduleForStopOTPMethodResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getStatistics
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Egyszerű végpont hibakereséshez, ami egy \&quot;OK\&quot; választ ad vissza. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getStatisticsCall(Dialect dialect, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/{dialect}/api/where/statistics"
            .replace("{" + "dialect" + "}", localVarApiClient.escapeString(dialect.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyQuery" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getStatisticsValidateBeforeCall(Dialect dialect, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'dialect' is set
        if (dialect == null) {
            throw new ApiException("Missing the required parameter 'dialect' when calling getStatistics(Async)");
        }

        return getStatisticsCall(dialect, _callback);

    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @return StatisticsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Egyszerű végpont hibakereséshez, ami egy \&quot;OK\&quot; választ ad vissza. </td><td>  -  </td></tr>
     </table>
     */
    public StatisticsResponse getStatistics(Dialect dialect) throws ApiException {
        ApiResponse<StatisticsResponse> localVarResp = getStatisticsWithHttpInfo(dialect);
        return localVarResp.getData();
    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @return ApiResponse&lt;StatisticsResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Egyszerű végpont hibakereséshez, ami egy \&quot;OK\&quot; választ ad vissza. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<StatisticsResponse> getStatisticsWithHttpInfo(Dialect dialect) throws ApiException {
        okhttp3.Call localVarCall = getStatisticsValidateBeforeCall(dialect, null);
        Type localVarReturnType = new TypeToken<StatisticsResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Egyszerű végpont hibakereséshez, ami egy \&quot;OK\&quot; választ ad vissza. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getStatisticsAsync(Dialect dialect, final ApiCallback<StatisticsResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getStatisticsValidateBeforeCall(dialect, _callback);
        Type localVarReturnType = new TypeToken<StatisticsResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getStopsForLocation
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param lat A helyszín középpontjának szélessgéi koordinátája. (optional)
     * @param lon A helyszín középpontjának hosszúsági koordinátája. (optional)
     * @param latSpan A lekérési terület szélességi íve. (Terület szélessége: &#x60;lat +/- latspan&#x60;). (optional)
     * @param lonSpan A lekérési terület hosszúsági íve. (Terület hosszúsága: &#x60;lon +/- lonSpan&#x60;). (optional)
     * @param radius Ha a &#x60;latSpan&#x60; vagy a &#x60;longSpan&#x60; nincs kitöltve, a keresési terület a középpontól számított &#x60;radius&#x60; méter távolság mind a négy irányban. (optional, default to 100)
     * @param query A válasz szűrésére használt keresési kifejezés. (optional)
     * @param minResult A visszaadott elemek minimális száma. (optional, default to 5)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Egy megállólistát ad vissza az adott helyhez. Ha a lat vagy a lon null, akkor az összes megálló bekerül a válaszba. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getStopsForLocationCall(Dialect dialect, Float lat, Float lon, Float latSpan, Float lonSpan, Integer radius, String query, Integer minResult, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/{dialect}/api/where/stops-for-location"
            .replace("{" + "dialect" + "}", localVarApiClient.escapeString(dialect.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (lat != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("lat", lat));
        }

        if (lon != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("lon", lon));
        }

        if (latSpan != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("latSpan", latSpan));
        }

        if (lonSpan != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("lonSpan", lonSpan));
        }

        if (radius != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("radius", radius));
        }

        if (query != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("query", query));
        }

        if (minResult != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minResult", minResult));
        }

        if (appVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("appVersion", appVersion));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("version", version));
        }

        if (includeReferences != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "includeReferences", includeReferences));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyQuery" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getStopsForLocationValidateBeforeCall(Dialect dialect, Float lat, Float lon, Float latSpan, Float lonSpan, Integer radius, String query, Integer minResult, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'dialect' is set
        if (dialect == null) {
            throw new ApiException("Missing the required parameter 'dialect' when calling getStopsForLocation(Async)");
        }

        return getStopsForLocationCall(dialect, lat, lon, latSpan, lonSpan, radius, query, minResult, appVersion, version, includeReferences, _callback);

    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param lat A helyszín középpontjának szélessgéi koordinátája. (optional)
     * @param lon A helyszín középpontjának hosszúsági koordinátája. (optional)
     * @param latSpan A lekérési terület szélességi íve. (Terület szélessége: &#x60;lat +/- latspan&#x60;). (optional)
     * @param lonSpan A lekérési terület hosszúsági íve. (Terület hosszúsága: &#x60;lon +/- lonSpan&#x60;). (optional)
     * @param radius Ha a &#x60;latSpan&#x60; vagy a &#x60;longSpan&#x60; nincs kitöltve, a keresési terület a középpontól számított &#x60;radius&#x60; méter távolság mind a négy irányban. (optional, default to 100)
     * @param query A válasz szűrésére használt keresési kifejezés. (optional)
     * @param minResult A visszaadott elemek minimális száma. (optional, default to 5)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return StopsForLocationResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Egy megállólistát ad vissza az adott helyhez. Ha a lat vagy a lon null, akkor az összes megálló bekerül a válaszba. </td><td>  -  </td></tr>
     </table>
     */
    public StopsForLocationResponse getStopsForLocation(Dialect dialect, Float lat, Float lon, Float latSpan, Float lonSpan, Integer radius, String query, Integer minResult, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        ApiResponse<StopsForLocationResponse> localVarResp = getStopsForLocationWithHttpInfo(dialect, lat, lon, latSpan, lonSpan, radius, query, minResult, appVersion, version, includeReferences);
        return localVarResp.getData();
    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param lat A helyszín középpontjának szélessgéi koordinátája. (optional)
     * @param lon A helyszín középpontjának hosszúsági koordinátája. (optional)
     * @param latSpan A lekérési terület szélességi íve. (Terület szélessége: &#x60;lat +/- latspan&#x60;). (optional)
     * @param lonSpan A lekérési terület hosszúsági íve. (Terület hosszúsága: &#x60;lon +/- lonSpan&#x60;). (optional)
     * @param radius Ha a &#x60;latSpan&#x60; vagy a &#x60;longSpan&#x60; nincs kitöltve, a keresési terület a középpontól számított &#x60;radius&#x60; méter távolság mind a négy irányban. (optional, default to 100)
     * @param query A válasz szűrésére használt keresési kifejezés. (optional)
     * @param minResult A visszaadott elemek minimális száma. (optional, default to 5)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return ApiResponse&lt;StopsForLocationResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Egy megállólistát ad vissza az adott helyhez. Ha a lat vagy a lon null, akkor az összes megálló bekerül a válaszba. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<StopsForLocationResponse> getStopsForLocationWithHttpInfo(Dialect dialect, Float lat, Float lon, Float latSpan, Float lonSpan, Integer radius, String query, Integer minResult, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        okhttp3.Call localVarCall = getStopsForLocationValidateBeforeCall(dialect, lat, lon, latSpan, lonSpan, radius, query, minResult, appVersion, version, includeReferences, null);
        Type localVarReturnType = new TypeToken<StopsForLocationResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param lat A helyszín középpontjának szélessgéi koordinátája. (optional)
     * @param lon A helyszín középpontjának hosszúsági koordinátája. (optional)
     * @param latSpan A lekérési terület szélességi íve. (Terület szélessége: &#x60;lat +/- latspan&#x60;). (optional)
     * @param lonSpan A lekérési terület hosszúsági íve. (Terület hosszúsága: &#x60;lon +/- lonSpan&#x60;). (optional)
     * @param radius Ha a &#x60;latSpan&#x60; vagy a &#x60;longSpan&#x60; nincs kitöltve, a keresési terület a középpontól számított &#x60;radius&#x60; méter távolság mind a négy irányban. (optional, default to 100)
     * @param query A válasz szűrésére használt keresési kifejezés. (optional)
     * @param minResult A visszaadott elemek minimális száma. (optional, default to 5)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Egy megállólistát ad vissza az adott helyhez. Ha a lat vagy a lon null, akkor az összes megálló bekerül a válaszba. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getStopsForLocationAsync(Dialect dialect, Float lat, Float lon, Float latSpan, Float lonSpan, Integer radius, String query, Integer minResult, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback<StopsForLocationResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getStopsForLocationValidateBeforeCall(dialect, lat, lon, latSpan, lonSpan, radius, query, minResult, appVersion, version, includeReferences, _callback);
        Type localVarReturnType = new TypeToken<StopsForLocationResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getTicketingData
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param ifModifiedSince Csak azokat az elemeket adjuk vissza, amik módosultak az itt megadott időbélyeg (UNIX időbélyeg másodpercben) után. Ha nincs változás üres listákkal tér vissza. Elsőbbsége van a header paraméterrel szemben. (optional, default to -1)
     * @param ifModifiedSince2 Ha meg van adva, akkor csak abban az esetben érkezik vissza adat, ha az változott a megadott időpont óta. Különben HTTP 304 a válasz. A query paraméternek elsőbbsége van ezzel szemben. (optional)
     * @param full Ha igaz, és az adat változott az &#x60;ifModifiedSince&#x60; query paraméterben megadott időpont óta, akkor az összes adat visszaadásra kerül. Ha nincs megadva csak a módosult elemek szerepelnek a válaszban. Csak az &#x60;ifModifiedSince&#x60; query paraméterrel együtt szerepelhet, mivel az &#x60;If-Modified-Since&#x60; fejléc minden esetben a teljes választ tartalmazza. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszaadja a jegyértékesítő helyeket és jegytípusokat. </td><td>  -  </td></tr>
        <tr><td> 304 </td><td> Nem változott az adat az &#x60;ifModifiedSince&#x60; query vagy header paraméterben megadott időpont óta. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getTicketingDataCall(Dialect dialect, Long ifModifiedSince, OffsetDateTime ifModifiedSince2, Boolean full, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/{dialect}/api/where/ticketing-locations"
            .replace("{" + "dialect" + "}", localVarApiClient.escapeString(dialect.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (ifModifiedSince != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ifModifiedSince", ifModifiedSince));
        }

        if (full != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("full", full));
        }

        if (appVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("appVersion", appVersion));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("version", version));
        }

        if (includeReferences != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "includeReferences", includeReferences));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (ifModifiedSince2 != null) {
            localVarHeaderParams.put("If-Modified-Since", localVarApiClient.parameterToString(ifModifiedSince2));
        }


        String[] localVarAuthNames = new String[] { "ApiKeyQuery" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getTicketingDataValidateBeforeCall(Dialect dialect, Long ifModifiedSince, OffsetDateTime ifModifiedSince2, Boolean full, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'dialect' is set
        if (dialect == null) {
            throw new ApiException("Missing the required parameter 'dialect' when calling getTicketingData(Async)");
        }

        return getTicketingDataCall(dialect, ifModifiedSince, ifModifiedSince2, full, appVersion, version, includeReferences, _callback);

    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param ifModifiedSince Csak azokat az elemeket adjuk vissza, amik módosultak az itt megadott időbélyeg (UNIX időbélyeg másodpercben) után. Ha nincs változás üres listákkal tér vissza. Elsőbbsége van a header paraméterrel szemben. (optional, default to -1)
     * @param ifModifiedSince2 Ha meg van adva, akkor csak abban az esetben érkezik vissza adat, ha az változott a megadott időpont óta. Különben HTTP 304 a válasz. A query paraméternek elsőbbsége van ezzel szemben. (optional)
     * @param full Ha igaz, és az adat változott az &#x60;ifModifiedSince&#x60; query paraméterben megadott időpont óta, akkor az összes adat visszaadásra kerül. Ha nincs megadva csak a módosult elemek szerepelnek a válaszban. Csak az &#x60;ifModifiedSince&#x60; query paraméterrel együtt szerepelhet, mivel az &#x60;If-Modified-Since&#x60; fejléc minden esetben a teljes választ tartalmazza. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return TicketingMethodResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszaadja a jegyértékesítő helyeket és jegytípusokat. </td><td>  -  </td></tr>
        <tr><td> 304 </td><td> Nem változott az adat az &#x60;ifModifiedSince&#x60; query vagy header paraméterben megadott időpont óta. </td><td>  -  </td></tr>
     </table>
     */
    public TicketingMethodResponse getTicketingData(Dialect dialect, Long ifModifiedSince, OffsetDateTime ifModifiedSince2, Boolean full, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        ApiResponse<TicketingMethodResponse> localVarResp = getTicketingDataWithHttpInfo(dialect, ifModifiedSince, ifModifiedSince2, full, appVersion, version, includeReferences);
        return localVarResp.getData();
    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param ifModifiedSince Csak azokat az elemeket adjuk vissza, amik módosultak az itt megadott időbélyeg (UNIX időbélyeg másodpercben) után. Ha nincs változás üres listákkal tér vissza. Elsőbbsége van a header paraméterrel szemben. (optional, default to -1)
     * @param ifModifiedSince2 Ha meg van adva, akkor csak abban az esetben érkezik vissza adat, ha az változott a megadott időpont óta. Különben HTTP 304 a válasz. A query paraméternek elsőbbsége van ezzel szemben. (optional)
     * @param full Ha igaz, és az adat változott az &#x60;ifModifiedSince&#x60; query paraméterben megadott időpont óta, akkor az összes adat visszaadásra kerül. Ha nincs megadva csak a módosult elemek szerepelnek a válaszban. Csak az &#x60;ifModifiedSince&#x60; query paraméterrel együtt szerepelhet, mivel az &#x60;If-Modified-Since&#x60; fejléc minden esetben a teljes választ tartalmazza. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return ApiResponse&lt;TicketingMethodResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszaadja a jegyértékesítő helyeket és jegytípusokat. </td><td>  -  </td></tr>
        <tr><td> 304 </td><td> Nem változott az adat az &#x60;ifModifiedSince&#x60; query vagy header paraméterben megadott időpont óta. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TicketingMethodResponse> getTicketingDataWithHttpInfo(Dialect dialect, Long ifModifiedSince, OffsetDateTime ifModifiedSince2, Boolean full, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        okhttp3.Call localVarCall = getTicketingDataValidateBeforeCall(dialect, ifModifiedSince, ifModifiedSince2, full, appVersion, version, includeReferences, null);
        Type localVarReturnType = new TypeToken<TicketingMethodResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param ifModifiedSince Csak azokat az elemeket adjuk vissza, amik módosultak az itt megadott időbélyeg (UNIX időbélyeg másodpercben) után. Ha nincs változás üres listákkal tér vissza. Elsőbbsége van a header paraméterrel szemben. (optional, default to -1)
     * @param ifModifiedSince2 Ha meg van adva, akkor csak abban az esetben érkezik vissza adat, ha az változott a megadott időpont óta. Különben HTTP 304 a válasz. A query paraméternek elsőbbsége van ezzel szemben. (optional)
     * @param full Ha igaz, és az adat változott az &#x60;ifModifiedSince&#x60; query paraméterben megadott időpont óta, akkor az összes adat visszaadásra kerül. Ha nincs megadva csak a módosult elemek szerepelnek a válaszban. Csak az &#x60;ifModifiedSince&#x60; query paraméterrel együtt szerepelhet, mivel az &#x60;If-Modified-Since&#x60; fejléc minden esetben a teljes választ tartalmazza. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszaadja a jegyértékesítő helyeket és jegytípusokat. </td><td>  -  </td></tr>
        <tr><td> 304 </td><td> Nem változott az adat az &#x60;ifModifiedSince&#x60; query vagy header paraméterben megadott időpont óta. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getTicketingDataAsync(Dialect dialect, Long ifModifiedSince, OffsetDateTime ifModifiedSince2, Boolean full, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback<TicketingMethodResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getTicketingDataValidateBeforeCall(dialect, ifModifiedSince, ifModifiedSince2, full, appVersion, version, includeReferences, _callback);
        Type localVarReturnType = new TypeToken<TicketingMethodResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getTripDetails
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param vehicleId Amennyiben meg van adva, azon menet érkezik a válaszban, amit az adott jármű teljesít. (optional)
     * @param tripId Ha nincs kitöltve a járműazonosító, az itt megadott azonosítóval rendelkező menet lesz a válaszban. (optional)
     * @param date Ha nincs kitöltve a járműazonosító, ezen a dátumon lesz keresve az adott azonosítójú menet. (optional)
     * @param ifModifiedSince Akkor adunk vissza adatot, ha az módosult az itt megadott időbélyeg (UNIX időbélyeg másodpercben) után. Ellenkező esetben HTTP 304 a válasz, ha nincs változás. Elsőbbsége van a header paraméterrel szemben. (optional, default to -1)
     * @param ifModifiedSince2 Ha meg van adva, akkor csak abban az esetben érkezik vissza adat, ha az változott a megadott időpont óta. Különben HTTP 304 a válasz. A query paraméternek elsőbbsége van ezzel szemben. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszaadja a részletes információit egy menetnek, ami az azonosítója és a dátum alapján, vagy az azt teljesítő jármű azonosítója alapján lett lekérve. </td><td>  -  </td></tr>
        <tr><td> 304 </td><td> Nem változott az adat az &#x60;ifModifiedSince&#x60; paraméterben megadott időpont óta. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Nem sikerült beolvasni a dátumot. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A következő esetek egyike: -Ismeretlen járműazonosító. -Ismereten menetazonosító. -A kért menet nem közlekedik az adott napon. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getTripDetailsCall(Dialect dialect, String vehicleId, String tripId, String date, Long ifModifiedSince, OffsetDateTime ifModifiedSince2, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/{dialect}/api/where/trip-details"
            .replace("{" + "dialect" + "}", localVarApiClient.escapeString(dialect.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (vehicleId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("vehicleId", vehicleId));
        }

        if (tripId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tripId", tripId));
        }

        if (date != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("date", date));
        }

        if (ifModifiedSince != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ifModifiedSince", ifModifiedSince));
        }

        if (appVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("appVersion", appVersion));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("version", version));
        }

        if (includeReferences != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "includeReferences", includeReferences));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (ifModifiedSince2 != null) {
            localVarHeaderParams.put("If-Modified-Since", localVarApiClient.parameterToString(ifModifiedSince2));
        }


        String[] localVarAuthNames = new String[] { "ApiKeyQuery" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getTripDetailsValidateBeforeCall(Dialect dialect, String vehicleId, String tripId, String date, Long ifModifiedSince, OffsetDateTime ifModifiedSince2, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'dialect' is set
        if (dialect == null) {
            throw new ApiException("Missing the required parameter 'dialect' when calling getTripDetails(Async)");
        }

        return getTripDetailsCall(dialect, vehicleId, tripId, date, ifModifiedSince, ifModifiedSince2, appVersion, version, includeReferences, _callback);

    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param vehicleId Amennyiben meg van adva, azon menet érkezik a válaszban, amit az adott jármű teljesít. (optional)
     * @param tripId Ha nincs kitöltve a járműazonosító, az itt megadott azonosítóval rendelkező menet lesz a válaszban. (optional)
     * @param date Ha nincs kitöltve a járműazonosító, ezen a dátumon lesz keresve az adott azonosítójú menet. (optional)
     * @param ifModifiedSince Akkor adunk vissza adatot, ha az módosult az itt megadott időbélyeg (UNIX időbélyeg másodpercben) után. Ellenkező esetben HTTP 304 a válasz, ha nincs változás. Elsőbbsége van a header paraméterrel szemben. (optional, default to -1)
     * @param ifModifiedSince2 Ha meg van adva, akkor csak abban az esetben érkezik vissza adat, ha az változott a megadott időpont óta. Különben HTTP 304 a válasz. A query paraméternek elsőbbsége van ezzel szemben. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return TripDetailsOTPMethodResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszaadja a részletes információit egy menetnek, ami az azonosítója és a dátum alapján, vagy az azt teljesítő jármű azonosítója alapján lett lekérve. </td><td>  -  </td></tr>
        <tr><td> 304 </td><td> Nem változott az adat az &#x60;ifModifiedSince&#x60; paraméterben megadott időpont óta. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Nem sikerült beolvasni a dátumot. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A következő esetek egyike: -Ismeretlen járműazonosító. -Ismereten menetazonosító. -A kért menet nem közlekedik az adott napon. </td><td>  -  </td></tr>
     </table>
     */
    public TripDetailsOTPMethodResponse getTripDetails(Dialect dialect, String vehicleId, String tripId, String date, Long ifModifiedSince, OffsetDateTime ifModifiedSince2, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        ApiResponse<TripDetailsOTPMethodResponse> localVarResp = getTripDetailsWithHttpInfo(dialect, vehicleId, tripId, date, ifModifiedSince, ifModifiedSince2, appVersion, version, includeReferences);
        return localVarResp.getData();
    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param vehicleId Amennyiben meg van adva, azon menet érkezik a válaszban, amit az adott jármű teljesít. (optional)
     * @param tripId Ha nincs kitöltve a járműazonosító, az itt megadott azonosítóval rendelkező menet lesz a válaszban. (optional)
     * @param date Ha nincs kitöltve a járműazonosító, ezen a dátumon lesz keresve az adott azonosítójú menet. (optional)
     * @param ifModifiedSince Akkor adunk vissza adatot, ha az módosult az itt megadott időbélyeg (UNIX időbélyeg másodpercben) után. Ellenkező esetben HTTP 304 a válasz, ha nincs változás. Elsőbbsége van a header paraméterrel szemben. (optional, default to -1)
     * @param ifModifiedSince2 Ha meg van adva, akkor csak abban az esetben érkezik vissza adat, ha az változott a megadott időpont óta. Különben HTTP 304 a válasz. A query paraméternek elsőbbsége van ezzel szemben. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return ApiResponse&lt;TripDetailsOTPMethodResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszaadja a részletes információit egy menetnek, ami az azonosítója és a dátum alapján, vagy az azt teljesítő jármű azonosítója alapján lett lekérve. </td><td>  -  </td></tr>
        <tr><td> 304 </td><td> Nem változott az adat az &#x60;ifModifiedSince&#x60; paraméterben megadott időpont óta. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Nem sikerült beolvasni a dátumot. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A következő esetek egyike: -Ismeretlen járműazonosító. -Ismereten menetazonosító. -A kért menet nem közlekedik az adott napon. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TripDetailsOTPMethodResponse> getTripDetailsWithHttpInfo(Dialect dialect, String vehicleId, String tripId, String date, Long ifModifiedSince, OffsetDateTime ifModifiedSince2, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        okhttp3.Call localVarCall = getTripDetailsValidateBeforeCall(dialect, vehicleId, tripId, date, ifModifiedSince, ifModifiedSince2, appVersion, version, includeReferences, null);
        Type localVarReturnType = new TypeToken<TripDetailsOTPMethodResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param vehicleId Amennyiben meg van adva, azon menet érkezik a válaszban, amit az adott jármű teljesít. (optional)
     * @param tripId Ha nincs kitöltve a járműazonosító, az itt megadott azonosítóval rendelkező menet lesz a válaszban. (optional)
     * @param date Ha nincs kitöltve a járműazonosító, ezen a dátumon lesz keresve az adott azonosítójú menet. (optional)
     * @param ifModifiedSince Akkor adunk vissza adatot, ha az módosult az itt megadott időbélyeg (UNIX időbélyeg másodpercben) után. Ellenkező esetben HTTP 304 a válasz, ha nincs változás. Elsőbbsége van a header paraméterrel szemben. (optional, default to -1)
     * @param ifModifiedSince2 Ha meg van adva, akkor csak abban az esetben érkezik vissza adat, ha az változott a megadott időpont óta. Különben HTTP 304 a válasz. A query paraméternek elsőbbsége van ezzel szemben. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszaadja a részletes információit egy menetnek, ami az azonosítója és a dátum alapján, vagy az azt teljesítő jármű azonosítója alapján lett lekérve. </td><td>  -  </td></tr>
        <tr><td> 304 </td><td> Nem változott az adat az &#x60;ifModifiedSince&#x60; paraméterben megadott időpont óta. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Nem sikerült beolvasni a dátumot. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A következő esetek egyike: -Ismeretlen járműazonosító. -Ismereten menetazonosító. -A kért menet nem közlekedik az adott napon. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getTripDetailsAsync(Dialect dialect, String vehicleId, String tripId, String date, Long ifModifiedSince, OffsetDateTime ifModifiedSince2, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback<TripDetailsOTPMethodResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getTripDetailsValidateBeforeCall(dialect, vehicleId, tripId, date, ifModifiedSince, ifModifiedSince2, appVersion, version, includeReferences, _callback);
        Type localVarReturnType = new TypeToken<TripDetailsOTPMethodResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getVehicleForTrip
     * @param tripId A lekért menetek azonosítói. (required)
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param date A lekért menetrendi napok. Alapértelmezetten az aktuális nap. (optional)
     * @param ifModifiedSince Akkor adunk vissza adatot, ha az módosult az itt megadott időbélyeg (UNIX időbélyeg másodpercben) után. Ellenkező esetben HTTP 304 a válasz, ha nincs változás. Elsőbbsége van a header paraméterrel szemben. (optional, default to -1)
     * @param ifModifiedSince2 Ha meg van adva, akkor csak abban az esetben érkezik vissza adat, ha az változott a megadott időpont óta. Különben HTTP 304 a válasz. A query paraméternek elsőbbsége van ezzel szemben. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszatér a megadott menetekhez és menetrendi napokhoz tartozó járművekkel. </td><td>  -  </td></tr>
        <tr><td> 304 </td><td> Nem változott az adat az &#x60;ifModifiedSince&#x60; paraméterben megadott időpont óta. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> A menet azonosítókat és menetrendi napokat tartalmazó tömbök mérete nem egyezik. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Az egyik menet azonosítóhoz nem található menet. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getVehicleForTripCall(List<String> tripId, Dialect dialect, List<String> date, Long ifModifiedSince, OffsetDateTime ifModifiedSince2, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/{dialect}/api/where/vehicle-for-trip"
            .replace("{" + "dialect" + "}", localVarApiClient.escapeString(dialect.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (tripId != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "tripId", tripId));
        }

        if (date != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "date", date));
        }

        if (ifModifiedSince != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ifModifiedSince", ifModifiedSince));
        }

        if (appVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("appVersion", appVersion));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("version", version));
        }

        if (includeReferences != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "includeReferences", includeReferences));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (ifModifiedSince2 != null) {
            localVarHeaderParams.put("If-Modified-Since", localVarApiClient.parameterToString(ifModifiedSince2));
        }


        String[] localVarAuthNames = new String[] { "ApiKeyQuery" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getVehicleForTripValidateBeforeCall(List<String> tripId, Dialect dialect, List<String> date, Long ifModifiedSince, OffsetDateTime ifModifiedSince2, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'tripId' is set
        if (tripId == null) {
            throw new ApiException("Missing the required parameter 'tripId' when calling getVehicleForTrip(Async)");
        }

        // verify the required parameter 'dialect' is set
        if (dialect == null) {
            throw new ApiException("Missing the required parameter 'dialect' when calling getVehicleForTrip(Async)");
        }

        return getVehicleForTripCall(tripId, dialect, date, ifModifiedSince, ifModifiedSince2, appVersion, version, includeReferences, _callback);

    }

    /**
     * 
     * 
     * @param tripId A lekért menetek azonosítói. (required)
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param date A lekért menetrendi napok. Alapértelmezetten az aktuális nap. (optional)
     * @param ifModifiedSince Akkor adunk vissza adatot, ha az módosult az itt megadott időbélyeg (UNIX időbélyeg másodpercben) után. Ellenkező esetben HTTP 304 a válasz, ha nincs változás. Elsőbbsége van a header paraméterrel szemben. (optional, default to -1)
     * @param ifModifiedSince2 Ha meg van adva, akkor csak abban az esetben érkezik vissza adat, ha az változott a megadott időpont óta. Különben HTTP 304 a válasz. A query paraméternek elsőbbsége van ezzel szemben. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return VehicleForTripMethodResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszatér a megadott menetekhez és menetrendi napokhoz tartozó járművekkel. </td><td>  -  </td></tr>
        <tr><td> 304 </td><td> Nem változott az adat az &#x60;ifModifiedSince&#x60; paraméterben megadott időpont óta. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> A menet azonosítókat és menetrendi napokat tartalmazó tömbök mérete nem egyezik. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Az egyik menet azonosítóhoz nem található menet. </td><td>  -  </td></tr>
     </table>
     */
    public VehicleForTripMethodResponse getVehicleForTrip(List<String> tripId, Dialect dialect, List<String> date, Long ifModifiedSince, OffsetDateTime ifModifiedSince2, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        ApiResponse<VehicleForTripMethodResponse> localVarResp = getVehicleForTripWithHttpInfo(tripId, dialect, date, ifModifiedSince, ifModifiedSince2, appVersion, version, includeReferences);
        return localVarResp.getData();
    }

    /**
     * 
     * 
     * @param tripId A lekért menetek azonosítói. (required)
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param date A lekért menetrendi napok. Alapértelmezetten az aktuális nap. (optional)
     * @param ifModifiedSince Akkor adunk vissza adatot, ha az módosult az itt megadott időbélyeg (UNIX időbélyeg másodpercben) után. Ellenkező esetben HTTP 304 a válasz, ha nincs változás. Elsőbbsége van a header paraméterrel szemben. (optional, default to -1)
     * @param ifModifiedSince2 Ha meg van adva, akkor csak abban az esetben érkezik vissza adat, ha az változott a megadott időpont óta. Különben HTTP 304 a válasz. A query paraméternek elsőbbsége van ezzel szemben. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return ApiResponse&lt;VehicleForTripMethodResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszatér a megadott menetekhez és menetrendi napokhoz tartozó járművekkel. </td><td>  -  </td></tr>
        <tr><td> 304 </td><td> Nem változott az adat az &#x60;ifModifiedSince&#x60; paraméterben megadott időpont óta. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> A menet azonosítókat és menetrendi napokat tartalmazó tömbök mérete nem egyezik. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Az egyik menet azonosítóhoz nem található menet. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<VehicleForTripMethodResponse> getVehicleForTripWithHttpInfo(List<String> tripId, Dialect dialect, List<String> date, Long ifModifiedSince, OffsetDateTime ifModifiedSince2, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        okhttp3.Call localVarCall = getVehicleForTripValidateBeforeCall(tripId, dialect, date, ifModifiedSince, ifModifiedSince2, appVersion, version, includeReferences, null);
        Type localVarReturnType = new TypeToken<VehicleForTripMethodResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param tripId A lekért menetek azonosítói. (required)
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param date A lekért menetrendi napok. Alapértelmezetten az aktuális nap. (optional)
     * @param ifModifiedSince Akkor adunk vissza adatot, ha az módosult az itt megadott időbélyeg (UNIX időbélyeg másodpercben) után. Ellenkező esetben HTTP 304 a válasz, ha nincs változás. Elsőbbsége van a header paraméterrel szemben. (optional, default to -1)
     * @param ifModifiedSince2 Ha meg van adva, akkor csak abban az esetben érkezik vissza adat, ha az változott a megadott időpont óta. Különben HTTP 304 a válasz. A query paraméternek elsőbbsége van ezzel szemben. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszatér a megadott menetekhez és menetrendi napokhoz tartozó járművekkel. </td><td>  -  </td></tr>
        <tr><td> 304 </td><td> Nem változott az adat az &#x60;ifModifiedSince&#x60; paraméterben megadott időpont óta. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> A menet azonosítókat és menetrendi napokat tartalmazó tömbök mérete nem egyezik. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Az egyik menet azonosítóhoz nem található menet. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getVehicleForTripAsync(List<String> tripId, Dialect dialect, List<String> date, Long ifModifiedSince, OffsetDateTime ifModifiedSince2, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback<VehicleForTripMethodResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getVehicleForTripValidateBeforeCall(tripId, dialect, date, ifModifiedSince, ifModifiedSince2, appVersion, version, includeReferences, _callback);
        Type localVarReturnType = new TypeToken<VehicleForTripMethodResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getVehiclesForLocation
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param query A válasz listát szűrő feltétel, amit tartalmaznia kell a jármű azonosítójának, rendszámának vagy a típusának. (optional)
     * @param lat A terület középpontjának szélességi koordinátája. (optional)
     * @param lon A terület középpontjának hosszúsági koordinátája. (optional)
     * @param latSpan A lekérési terület szélességi íve. (Terület szélessége: &#x60;lat +/- latspan&#x60;). (optional)
     * @param lonSpan A lekérési terület hosszúsági íve. (Terület hosszúsága: &#x60;lon +/- lonSpan&#x60;). (optional)
     * @param radius Ha a &#x60;latSpan&#x60; vagy a &#x60;longSpan&#x60; nincs kitöltve, a keresési terület a középpontól számított &#x60;radius&#x60; méter távolság mind a négy irányban. (optional, default to 100)
     * @param ifModifiedSince Akkor adunk vissza adatot, ha az módosult az itt megadott időbélyeg (UNIX időbélyeg másodpercben) után. Ellenkező esetben HTTP 304 a válasz, ha nincs változás. Elsőbbsége van a header paraméterrel szemben. (optional, default to -1)
     * @param ifModifiedSince2 Ha meg van adva, akkor csak abban az esetben érkezik vissza adat, ha az változott a megadott időpont óta. Különben HTTP 304 a válasz. A query paraméternek elsőbbsége van ezzel szemben. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszatér az adott területen található összes járművel. Ha a &#x60;lat&#x60; vagy a &#x60;lon&#x60; null, az összes jármű benne lesz a válaszban. </td><td>  -  </td></tr>
        <tr><td> 304 </td><td> Nem változott az adat az &#x60;ifModifiedSince&#x60; paraméterben megadott időpont óta. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getVehiclesForLocationCall(Dialect dialect, String query, Float lat, Float lon, Float latSpan, Float lonSpan, Integer radius, Long ifModifiedSince, OffsetDateTime ifModifiedSince2, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/{dialect}/api/where/vehicles-for-location"
            .replace("{" + "dialect" + "}", localVarApiClient.escapeString(dialect.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (query != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("query", query));
        }

        if (lat != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("lat", lat));
        }

        if (lon != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("lon", lon));
        }

        if (latSpan != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("latSpan", latSpan));
        }

        if (lonSpan != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("lonSpan", lonSpan));
        }

        if (radius != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("radius", radius));
        }

        if (ifModifiedSince != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ifModifiedSince", ifModifiedSince));
        }

        if (appVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("appVersion", appVersion));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("version", version));
        }

        if (includeReferences != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "includeReferences", includeReferences));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (ifModifiedSince2 != null) {
            localVarHeaderParams.put("If-Modified-Since", localVarApiClient.parameterToString(ifModifiedSince2));
        }


        String[] localVarAuthNames = new String[] { "ApiKeyQuery" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getVehiclesForLocationValidateBeforeCall(Dialect dialect, String query, Float lat, Float lon, Float latSpan, Float lonSpan, Integer radius, Long ifModifiedSince, OffsetDateTime ifModifiedSince2, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'dialect' is set
        if (dialect == null) {
            throw new ApiException("Missing the required parameter 'dialect' when calling getVehiclesForLocation(Async)");
        }

        return getVehiclesForLocationCall(dialect, query, lat, lon, latSpan, lonSpan, radius, ifModifiedSince, ifModifiedSince2, appVersion, version, includeReferences, _callback);

    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param query A válasz listát szűrő feltétel, amit tartalmaznia kell a jármű azonosítójának, rendszámának vagy a típusának. (optional)
     * @param lat A terület középpontjának szélességi koordinátája. (optional)
     * @param lon A terület középpontjának hosszúsági koordinátája. (optional)
     * @param latSpan A lekérési terület szélességi íve. (Terület szélessége: &#x60;lat +/- latspan&#x60;). (optional)
     * @param lonSpan A lekérési terület hosszúsági íve. (Terület hosszúsága: &#x60;lon +/- lonSpan&#x60;). (optional)
     * @param radius Ha a &#x60;latSpan&#x60; vagy a &#x60;longSpan&#x60; nincs kitöltve, a keresési terület a középpontól számított &#x60;radius&#x60; méter távolság mind a négy irányban. (optional, default to 100)
     * @param ifModifiedSince Akkor adunk vissza adatot, ha az módosult az itt megadott időbélyeg (UNIX időbélyeg másodpercben) után. Ellenkező esetben HTTP 304 a válasz, ha nincs változás. Elsőbbsége van a header paraméterrel szemben. (optional, default to -1)
     * @param ifModifiedSince2 Ha meg van adva, akkor csak abban az esetben érkezik vissza adat, ha az változott a megadott időpont óta. Különben HTTP 304 a válasz. A query paraméternek elsőbbsége van ezzel szemben. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return VehiclesForLocationMethodResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszatér az adott területen található összes járművel. Ha a &#x60;lat&#x60; vagy a &#x60;lon&#x60; null, az összes jármű benne lesz a válaszban. </td><td>  -  </td></tr>
        <tr><td> 304 </td><td> Nem változott az adat az &#x60;ifModifiedSince&#x60; paraméterben megadott időpont óta. </td><td>  -  </td></tr>
     </table>
     */
    public VehiclesForLocationMethodResponse getVehiclesForLocation(Dialect dialect, String query, Float lat, Float lon, Float latSpan, Float lonSpan, Integer radius, Long ifModifiedSince, OffsetDateTime ifModifiedSince2, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        ApiResponse<VehiclesForLocationMethodResponse> localVarResp = getVehiclesForLocationWithHttpInfo(dialect, query, lat, lon, latSpan, lonSpan, radius, ifModifiedSince, ifModifiedSince2, appVersion, version, includeReferences);
        return localVarResp.getData();
    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param query A válasz listát szűrő feltétel, amit tartalmaznia kell a jármű azonosítójának, rendszámának vagy a típusának. (optional)
     * @param lat A terület középpontjának szélességi koordinátája. (optional)
     * @param lon A terület középpontjának hosszúsági koordinátája. (optional)
     * @param latSpan A lekérési terület szélességi íve. (Terület szélessége: &#x60;lat +/- latspan&#x60;). (optional)
     * @param lonSpan A lekérési terület hosszúsági íve. (Terület hosszúsága: &#x60;lon +/- lonSpan&#x60;). (optional)
     * @param radius Ha a &#x60;latSpan&#x60; vagy a &#x60;longSpan&#x60; nincs kitöltve, a keresési terület a középpontól számított &#x60;radius&#x60; méter távolság mind a négy irányban. (optional, default to 100)
     * @param ifModifiedSince Akkor adunk vissza adatot, ha az módosult az itt megadott időbélyeg (UNIX időbélyeg másodpercben) után. Ellenkező esetben HTTP 304 a válasz, ha nincs változás. Elsőbbsége van a header paraméterrel szemben. (optional, default to -1)
     * @param ifModifiedSince2 Ha meg van adva, akkor csak abban az esetben érkezik vissza adat, ha az változott a megadott időpont óta. Különben HTTP 304 a válasz. A query paraméternek elsőbbsége van ezzel szemben. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return ApiResponse&lt;VehiclesForLocationMethodResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszatér az adott területen található összes járművel. Ha a &#x60;lat&#x60; vagy a &#x60;lon&#x60; null, az összes jármű benne lesz a válaszban. </td><td>  -  </td></tr>
        <tr><td> 304 </td><td> Nem változott az adat az &#x60;ifModifiedSince&#x60; paraméterben megadott időpont óta. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<VehiclesForLocationMethodResponse> getVehiclesForLocationWithHttpInfo(Dialect dialect, String query, Float lat, Float lon, Float latSpan, Float lonSpan, Integer radius, Long ifModifiedSince, OffsetDateTime ifModifiedSince2, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        okhttp3.Call localVarCall = getVehiclesForLocationValidateBeforeCall(dialect, query, lat, lon, latSpan, lonSpan, radius, ifModifiedSince, ifModifiedSince2, appVersion, version, includeReferences, null);
        Type localVarReturnType = new TypeToken<VehiclesForLocationMethodResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param query A válasz listát szűrő feltétel, amit tartalmaznia kell a jármű azonosítójának, rendszámának vagy a típusának. (optional)
     * @param lat A terület középpontjának szélességi koordinátája. (optional)
     * @param lon A terület középpontjának hosszúsági koordinátája. (optional)
     * @param latSpan A lekérési terület szélességi íve. (Terület szélessége: &#x60;lat +/- latspan&#x60;). (optional)
     * @param lonSpan A lekérési terület hosszúsági íve. (Terület hosszúsága: &#x60;lon +/- lonSpan&#x60;). (optional)
     * @param radius Ha a &#x60;latSpan&#x60; vagy a &#x60;longSpan&#x60; nincs kitöltve, a keresési terület a középpontól számított &#x60;radius&#x60; méter távolság mind a négy irányban. (optional, default to 100)
     * @param ifModifiedSince Akkor adunk vissza adatot, ha az módosult az itt megadott időbélyeg (UNIX időbélyeg másodpercben) után. Ellenkező esetben HTTP 304 a válasz, ha nincs változás. Elsőbbsége van a header paraméterrel szemben. (optional, default to -1)
     * @param ifModifiedSince2 Ha meg van adva, akkor csak abban az esetben érkezik vissza adat, ha az változott a megadott időpont óta. Különben HTTP 304 a válasz. A query paraméternek elsőbbsége van ezzel szemben. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszatér az adott területen található összes járművel. Ha a &#x60;lat&#x60; vagy a &#x60;lon&#x60; null, az összes jármű benne lesz a válaszban. </td><td>  -  </td></tr>
        <tr><td> 304 </td><td> Nem változott az adat az &#x60;ifModifiedSince&#x60; paraméterben megadott időpont óta. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getVehiclesForLocationAsync(Dialect dialect, String query, Float lat, Float lon, Float latSpan, Float lonSpan, Integer radius, Long ifModifiedSince, OffsetDateTime ifModifiedSince2, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback<VehiclesForLocationMethodResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getVehiclesForLocationValidateBeforeCall(dialect, query, lat, lon, latSpan, lonSpan, radius, ifModifiedSince, ifModifiedSince2, appVersion, version, includeReferences, _callback);
        Type localVarReturnType = new TypeToken<VehiclesForLocationMethodResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getVehiclesForRoute
     * @param routeId A lekért járatok azonosítói. (required)
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param related Tartalmazza-e a válasz a kapcsolódó járatokat is a referenciákban. (optional, default to false)
     * @param ifModifiedSince Akkor adunk vissza adatot, ha az módosult az itt megadott időbélyeg (UNIX időbélyeg másodpercben) után. Ellenkező esetben HTTP 304 a válasz, ha nincs változás. Elsőbbsége van a header paraméterrel szemben. (optional, default to -1)
     * @param ifModifiedSince2 Ha meg van adva, akkor csak abban az esetben érkezik vissza adat, ha az változott a megadott időpont óta. Különben HTTP 304 a válasz. A query paraméternek elsőbbsége van ezzel szemben. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A megadott járat azonosítókhoz tartozó járművekkel tér vissza. </td><td>  -  </td></tr>
        <tr><td> 304 </td><td> Nem változott az adat az &#x60;ifModifiedSince&#x60; paraméterben megadott időpont óta. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A járat azonosítóhoz nem található járat. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getVehiclesForRouteCall(List<String> routeId, Dialect dialect, Boolean related, Long ifModifiedSince, OffsetDateTime ifModifiedSince2, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/{dialect}/api/where/vehicles-for-route"
            .replace("{" + "dialect" + "}", localVarApiClient.escapeString(dialect.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (routeId != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "routeId", routeId));
        }

        if (related != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("related", related));
        }

        if (ifModifiedSince != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ifModifiedSince", ifModifiedSince));
        }

        if (appVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("appVersion", appVersion));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("version", version));
        }

        if (includeReferences != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "includeReferences", includeReferences));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (ifModifiedSince2 != null) {
            localVarHeaderParams.put("If-Modified-Since", localVarApiClient.parameterToString(ifModifiedSince2));
        }


        String[] localVarAuthNames = new String[] { "ApiKeyQuery" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getVehiclesForRouteValidateBeforeCall(List<String> routeId, Dialect dialect, Boolean related, Long ifModifiedSince, OffsetDateTime ifModifiedSince2, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'routeId' is set
        if (routeId == null) {
            throw new ApiException("Missing the required parameter 'routeId' when calling getVehiclesForRoute(Async)");
        }

        // verify the required parameter 'dialect' is set
        if (dialect == null) {
            throw new ApiException("Missing the required parameter 'dialect' when calling getVehiclesForRoute(Async)");
        }

        return getVehiclesForRouteCall(routeId, dialect, related, ifModifiedSince, ifModifiedSince2, appVersion, version, includeReferences, _callback);

    }

    /**
     * 
     * 
     * @param routeId A lekért járatok azonosítói. (required)
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param related Tartalmazza-e a válasz a kapcsolódó járatokat is a referenciákban. (optional, default to false)
     * @param ifModifiedSince Akkor adunk vissza adatot, ha az módosult az itt megadott időbélyeg (UNIX időbélyeg másodpercben) után. Ellenkező esetben HTTP 304 a válasz, ha nincs változás. Elsőbbsége van a header paraméterrel szemben. (optional, default to -1)
     * @param ifModifiedSince2 Ha meg van adva, akkor csak abban az esetben érkezik vissza adat, ha az változott a megadott időpont óta. Különben HTTP 304 a válasz. A query paraméternek elsőbbsége van ezzel szemben. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return VehiclesForRouteMethodResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A megadott járat azonosítókhoz tartozó járművekkel tér vissza. </td><td>  -  </td></tr>
        <tr><td> 304 </td><td> Nem változott az adat az &#x60;ifModifiedSince&#x60; paraméterben megadott időpont óta. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A járat azonosítóhoz nem található járat. </td><td>  -  </td></tr>
     </table>
     */
    public VehiclesForRouteMethodResponse getVehiclesForRoute(List<String> routeId, Dialect dialect, Boolean related, Long ifModifiedSince, OffsetDateTime ifModifiedSince2, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        ApiResponse<VehiclesForRouteMethodResponse> localVarResp = getVehiclesForRouteWithHttpInfo(routeId, dialect, related, ifModifiedSince, ifModifiedSince2, appVersion, version, includeReferences);
        return localVarResp.getData();
    }

    /**
     * 
     * 
     * @param routeId A lekért járatok azonosítói. (required)
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param related Tartalmazza-e a válasz a kapcsolódó járatokat is a referenciákban. (optional, default to false)
     * @param ifModifiedSince Akkor adunk vissza adatot, ha az módosult az itt megadott időbélyeg (UNIX időbélyeg másodpercben) után. Ellenkező esetben HTTP 304 a válasz, ha nincs változás. Elsőbbsége van a header paraméterrel szemben. (optional, default to -1)
     * @param ifModifiedSince2 Ha meg van adva, akkor csak abban az esetben érkezik vissza adat, ha az változott a megadott időpont óta. Különben HTTP 304 a válasz. A query paraméternek elsőbbsége van ezzel szemben. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return ApiResponse&lt;VehiclesForRouteMethodResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A megadott járat azonosítókhoz tartozó járművekkel tér vissza. </td><td>  -  </td></tr>
        <tr><td> 304 </td><td> Nem változott az adat az &#x60;ifModifiedSince&#x60; paraméterben megadott időpont óta. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A járat azonosítóhoz nem található járat. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<VehiclesForRouteMethodResponse> getVehiclesForRouteWithHttpInfo(List<String> routeId, Dialect dialect, Boolean related, Long ifModifiedSince, OffsetDateTime ifModifiedSince2, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        okhttp3.Call localVarCall = getVehiclesForRouteValidateBeforeCall(routeId, dialect, related, ifModifiedSince, ifModifiedSince2, appVersion, version, includeReferences, null);
        Type localVarReturnType = new TypeToken<VehiclesForRouteMethodResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param routeId A lekért járatok azonosítói. (required)
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param related Tartalmazza-e a válasz a kapcsolódó járatokat is a referenciákban. (optional, default to false)
     * @param ifModifiedSince Akkor adunk vissza adatot, ha az módosult az itt megadott időbélyeg (UNIX időbélyeg másodpercben) után. Ellenkező esetben HTTP 304 a válasz, ha nincs változás. Elsőbbsége van a header paraméterrel szemben. (optional, default to -1)
     * @param ifModifiedSince2 Ha meg van adva, akkor csak abban az esetben érkezik vissza adat, ha az változott a megadott időpont óta. Különben HTTP 304 a válasz. A query paraméternek elsőbbsége van ezzel szemben. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A megadott járat azonosítókhoz tartozó járművekkel tér vissza. </td><td>  -  </td></tr>
        <tr><td> 304 </td><td> Nem változott az adat az &#x60;ifModifiedSince&#x60; paraméterben megadott időpont óta. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A járat azonosítóhoz nem található járat. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getVehiclesForRouteAsync(List<String> routeId, Dialect dialect, Boolean related, Long ifModifiedSince, OffsetDateTime ifModifiedSince2, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback<VehiclesForRouteMethodResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getVehiclesForRouteValidateBeforeCall(routeId, dialect, related, ifModifiedSince, ifModifiedSince2, appVersion, version, includeReferences, _callback);
        Type localVarReturnType = new TypeToken<VehiclesForRouteMethodResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getVehiclesForStop
     * @param stopId A lekért megálló azonosítója. (required)
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param ifModifiedSince Akkor adunk vissza adatot, ha az módosult az itt megadott időbélyeg (UNIX időbélyeg másodpercben) után. Ellenkező esetben HTTP 304 a válasz, ha nincs változás. Elsőbbsége van a header paraméterrel szemben. (optional, default to -1)
     * @param ifModifiedSince2 Ha meg van adva, akkor csak abban az esetben érkezik vissza adat, ha az változott a megadott időpont óta. Különben HTTP 304 a válasz. A query paraméternek elsőbbsége van ezzel szemben. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszaadja az összes járművet, ami olyan menetet teljesít, ami tartalmazza a megadott megállót. </td><td>  -  </td></tr>
        <tr><td> 304 </td><td> Nem változott az adat az &#x60;ifModifiedSince&#x60; paraméterben megadott időpont óta. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A megálló azonosítóhoz nem található megálló. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getVehiclesForStopCall(String stopId, Dialect dialect, Long ifModifiedSince, OffsetDateTime ifModifiedSince2, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/{dialect}/api/where/vehicles-for-stop"
            .replace("{" + "dialect" + "}", localVarApiClient.escapeString(dialect.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (stopId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("stopId", stopId));
        }

        if (ifModifiedSince != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ifModifiedSince", ifModifiedSince));
        }

        if (appVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("appVersion", appVersion));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("version", version));
        }

        if (includeReferences != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "includeReferences", includeReferences));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (ifModifiedSince2 != null) {
            localVarHeaderParams.put("If-Modified-Since", localVarApiClient.parameterToString(ifModifiedSince2));
        }


        String[] localVarAuthNames = new String[] { "ApiKeyQuery" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getVehiclesForStopValidateBeforeCall(String stopId, Dialect dialect, Long ifModifiedSince, OffsetDateTime ifModifiedSince2, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'stopId' is set
        if (stopId == null) {
            throw new ApiException("Missing the required parameter 'stopId' when calling getVehiclesForStop(Async)");
        }

        // verify the required parameter 'dialect' is set
        if (dialect == null) {
            throw new ApiException("Missing the required parameter 'dialect' when calling getVehiclesForStop(Async)");
        }

        return getVehiclesForStopCall(stopId, dialect, ifModifiedSince, ifModifiedSince2, appVersion, version, includeReferences, _callback);

    }

    /**
     * 
     * 
     * @param stopId A lekért megálló azonosítója. (required)
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param ifModifiedSince Akkor adunk vissza adatot, ha az módosult az itt megadott időbélyeg (UNIX időbélyeg másodpercben) után. Ellenkező esetben HTTP 304 a válasz, ha nincs változás. Elsőbbsége van a header paraméterrel szemben. (optional, default to -1)
     * @param ifModifiedSince2 Ha meg van adva, akkor csak abban az esetben érkezik vissza adat, ha az változott a megadott időpont óta. Különben HTTP 304 a válasz. A query paraméternek elsőbbsége van ezzel szemben. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return VehiclesForStopMethodResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszaadja az összes járművet, ami olyan menetet teljesít, ami tartalmazza a megadott megállót. </td><td>  -  </td></tr>
        <tr><td> 304 </td><td> Nem változott az adat az &#x60;ifModifiedSince&#x60; paraméterben megadott időpont óta. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A megálló azonosítóhoz nem található megálló. </td><td>  -  </td></tr>
     </table>
     */
    public VehiclesForStopMethodResponse getVehiclesForStop(String stopId, Dialect dialect, Long ifModifiedSince, OffsetDateTime ifModifiedSince2, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        ApiResponse<VehiclesForStopMethodResponse> localVarResp = getVehiclesForStopWithHttpInfo(stopId, dialect, ifModifiedSince, ifModifiedSince2, appVersion, version, includeReferences);
        return localVarResp.getData();
    }

    /**
     * 
     * 
     * @param stopId A lekért megálló azonosítója. (required)
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param ifModifiedSince Akkor adunk vissza adatot, ha az módosult az itt megadott időbélyeg (UNIX időbélyeg másodpercben) után. Ellenkező esetben HTTP 304 a válasz, ha nincs változás. Elsőbbsége van a header paraméterrel szemben. (optional, default to -1)
     * @param ifModifiedSince2 Ha meg van adva, akkor csak abban az esetben érkezik vissza adat, ha az változott a megadott időpont óta. Különben HTTP 304 a válasz. A query paraméternek elsőbbsége van ezzel szemben. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return ApiResponse&lt;VehiclesForStopMethodResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszaadja az összes járművet, ami olyan menetet teljesít, ami tartalmazza a megadott megállót. </td><td>  -  </td></tr>
        <tr><td> 304 </td><td> Nem változott az adat az &#x60;ifModifiedSince&#x60; paraméterben megadott időpont óta. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A megálló azonosítóhoz nem található megálló. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<VehiclesForStopMethodResponse> getVehiclesForStopWithHttpInfo(String stopId, Dialect dialect, Long ifModifiedSince, OffsetDateTime ifModifiedSince2, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        okhttp3.Call localVarCall = getVehiclesForStopValidateBeforeCall(stopId, dialect, ifModifiedSince, ifModifiedSince2, appVersion, version, includeReferences, null);
        Type localVarReturnType = new TypeToken<VehiclesForStopMethodResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param stopId A lekért megálló azonosítója. (required)
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param ifModifiedSince Akkor adunk vissza adatot, ha az módosult az itt megadott időbélyeg (UNIX időbélyeg másodpercben) után. Ellenkező esetben HTTP 304 a válasz, ha nincs változás. Elsőbbsége van a header paraméterrel szemben. (optional, default to -1)
     * @param ifModifiedSince2 Ha meg van adva, akkor csak abban az esetben érkezik vissza adat, ha az változott a megadott időpont óta. Különben HTTP 304 a válasz. A query paraméternek elsőbbsége van ezzel szemben. (optional)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszaadja az összes járművet, ami olyan menetet teljesít, ami tartalmazza a megadott megállót. </td><td>  -  </td></tr>
        <tr><td> 304 </td><td> Nem változott az adat az &#x60;ifModifiedSince&#x60; paraméterben megadott időpont óta. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A megálló azonosítóhoz nem található megálló. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getVehiclesForStopAsync(String stopId, Dialect dialect, Long ifModifiedSince, OffsetDateTime ifModifiedSince2, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback<VehiclesForStopMethodResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getVehiclesForStopValidateBeforeCall(stopId, dialect, ifModifiedSince, ifModifiedSince2, appVersion, version, includeReferences, _callback);
        Type localVarReturnType = new TypeToken<VehiclesForStopMethodResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for planAccess
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param fromPlace Az indulási hely adatai &#x60;név::hely&#x60; formában. A &#x60;név&#x60; az adott hely tetszőleges neve, amely az útiterv kiindulási pontjának lesz a neve (&#x60;leg.from.name&#x60;). A &#x60;hely&#x60; lehet koordináta &#x60;lat,lon&#x60; formában, vagy a geocoder API által visszaadott &#x60;vertex&#x60; azonosítója. (required)
     * @param toPlace Az érkezési hely adatai &#x60;név::hely&#x60; formában. A &#x60;név&#x60; az adott hely tetszőleges neve, amely az útiterv érkezési pontjának lesz a neve (&#x60;leg.to.name&#x60;). A &#x60;hely&#x60; lehet koordináta &#x60;lat,lon&#x60; formában, vagy a geocoder API által visszaadott &#x60;vertex&#x60; azonosítója. (required)
     * @param mode A tervező milyen közlekedési módokat használjon. A kerékpár kölcsönzés a &#x60;BICYCLE,WALK&#x60; paraméterekkel kapcsolható be. (required)
     * @param version Az API verziója. (optional, default to 2)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param date A dátum, amikor a tervezés indul (&#x60;arriveBy&#x60; esetén érkezik). (optional)
     * @param time Az idő, amikor a tervezés indul (&#x60;arriveBy&#x60; esetén érkezik). (optional)
     * @param shouldBuyTickets Az első járműre szállás előtt történjen-e jegyvásárlás. (optional)
     * @param showIntermediateStops A válasz tartalmazza-e a járatok által érintett köztes megállókat is. (optional)
     * @param arriveBy Érkezési időre tervezzünk-e a megadott &#x60;date&#x60; és &#x60;time&#x60; paraméterrel. (optional)
     * @param wheelchair Az összes járat alacsonypadlós legyen-e. (optional)
     * @param triangleSafetyFactor Kerékpáros háromszög módú tervezés esetén mennyire számít a biztonság. 0 és 1 közötti szám, és 1-et kell kiadnia a másik két faktor összegével. (optional)
     * @param triangleSlopeFactor Kerékpáros háromszög módú tervezés esetén mennyire számít az útvonal síksága. 0 és 1 közötti szám, és 1-et kell kiadnia a másik két faktor összegével. (optional)
     * @param triangleTimeFactor Kerékpáros háromszög módú tervezés esetén mennyire számít a gyorsaság. 0 és 1 közötti szám, és 1-et kell kiadnia a másik két faktor összegével. (optional)
     * @param optimize A kereső mire optimalizálja az útvonalakat. (optional, default to BEST)
     * @param walkProfile A séta sebességét meghatározó profil. (optional, default to MID)
     * @param numItineraries Legfeljebb hány útvonal szerepeljen a válaszban. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A megadott paraméterekkel tervez megállóba útvonalat. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call planAccessCall(Dialect dialect, String fromPlace, String toPlace, List<TraverseMode> mode, ApiVersion version, String appVersion, List<ReferencesSchema> includeReferences, String date, String time, Boolean shouldBuyTickets, Boolean showIntermediateStops, Boolean arriveBy, Boolean wheelchair, Double triangleSafetyFactor, Double triangleSlopeFactor, Double triangleTimeFactor, String optimize, WalkProfile walkProfile, Integer numItineraries, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/{dialect}/api/where/plan-access"
            .replace("{" + "dialect" + "}", localVarApiClient.escapeString(dialect.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("version", version));
        }

        if (appVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("appVersion", appVersion));
        }

        if (includeReferences != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "includeReferences", includeReferences));
        }

        if (date != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("date", date));
        }

        if (time != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("time", time));
        }

        if (fromPlace != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromPlace", fromPlace));
        }

        if (toPlace != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("toPlace", toPlace));
        }

        if (mode != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "mode", mode));
        }

        if (shouldBuyTickets != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("shouldBuyTickets", shouldBuyTickets));
        }

        if (showIntermediateStops != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("showIntermediateStops", showIntermediateStops));
        }

        if (arriveBy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("arriveBy", arriveBy));
        }

        if (wheelchair != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("wheelchair", wheelchair));
        }

        if (triangleSafetyFactor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("triangleSafetyFactor", triangleSafetyFactor));
        }

        if (triangleSlopeFactor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("triangleSlopeFactor", triangleSlopeFactor));
        }

        if (triangleTimeFactor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("triangleTimeFactor", triangleTimeFactor));
        }

        if (optimize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("optimize", optimize));
        }

        if (walkProfile != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("walkProfile", walkProfile));
        }

        if (numItineraries != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("numItineraries", numItineraries));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyQuery" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call planAccessValidateBeforeCall(Dialect dialect, String fromPlace, String toPlace, List<TraverseMode> mode, ApiVersion version, String appVersion, List<ReferencesSchema> includeReferences, String date, String time, Boolean shouldBuyTickets, Boolean showIntermediateStops, Boolean arriveBy, Boolean wheelchair, Double triangleSafetyFactor, Double triangleSlopeFactor, Double triangleTimeFactor, String optimize, WalkProfile walkProfile, Integer numItineraries, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'dialect' is set
        if (dialect == null) {
            throw new ApiException("Missing the required parameter 'dialect' when calling planAccess(Async)");
        }

        // verify the required parameter 'fromPlace' is set
        if (fromPlace == null) {
            throw new ApiException("Missing the required parameter 'fromPlace' when calling planAccess(Async)");
        }

        // verify the required parameter 'toPlace' is set
        if (toPlace == null) {
            throw new ApiException("Missing the required parameter 'toPlace' when calling planAccess(Async)");
        }

        // verify the required parameter 'mode' is set
        if (mode == null) {
            throw new ApiException("Missing the required parameter 'mode' when calling planAccess(Async)");
        }

        return planAccessCall(dialect, fromPlace, toPlace, mode, version, appVersion, includeReferences, date, time, shouldBuyTickets, showIntermediateStops, arriveBy, wheelchair, triangleSafetyFactor, triangleSlopeFactor, triangleTimeFactor, optimize, walkProfile, numItineraries, _callback);

    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param fromPlace Az indulási hely adatai &#x60;név::hely&#x60; formában. A &#x60;név&#x60; az adott hely tetszőleges neve, amely az útiterv kiindulási pontjának lesz a neve (&#x60;leg.from.name&#x60;). A &#x60;hely&#x60; lehet koordináta &#x60;lat,lon&#x60; formában, vagy a geocoder API által visszaadott &#x60;vertex&#x60; azonosítója. (required)
     * @param toPlace Az érkezési hely adatai &#x60;név::hely&#x60; formában. A &#x60;név&#x60; az adott hely tetszőleges neve, amely az útiterv érkezési pontjának lesz a neve (&#x60;leg.to.name&#x60;). A &#x60;hely&#x60; lehet koordináta &#x60;lat,lon&#x60; formában, vagy a geocoder API által visszaadott &#x60;vertex&#x60; azonosítója. (required)
     * @param mode A tervező milyen közlekedési módokat használjon. A kerékpár kölcsönzés a &#x60;BICYCLE,WALK&#x60; paraméterekkel kapcsolható be. (required)
     * @param version Az API verziója. (optional, default to 2)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param date A dátum, amikor a tervezés indul (&#x60;arriveBy&#x60; esetén érkezik). (optional)
     * @param time Az idő, amikor a tervezés indul (&#x60;arriveBy&#x60; esetén érkezik). (optional)
     * @param shouldBuyTickets Az első járműre szállás előtt történjen-e jegyvásárlás. (optional)
     * @param showIntermediateStops A válasz tartalmazza-e a járatok által érintett köztes megállókat is. (optional)
     * @param arriveBy Érkezési időre tervezzünk-e a megadott &#x60;date&#x60; és &#x60;time&#x60; paraméterrel. (optional)
     * @param wheelchair Az összes járat alacsonypadlós legyen-e. (optional)
     * @param triangleSafetyFactor Kerékpáros háromszög módú tervezés esetén mennyire számít a biztonság. 0 és 1 közötti szám, és 1-et kell kiadnia a másik két faktor összegével. (optional)
     * @param triangleSlopeFactor Kerékpáros háromszög módú tervezés esetén mennyire számít az útvonal síksága. 0 és 1 közötti szám, és 1-et kell kiadnia a másik két faktor összegével. (optional)
     * @param triangleTimeFactor Kerékpáros háromszög módú tervezés esetén mennyire számít a gyorsaság. 0 és 1 közötti szám, és 1-et kell kiadnia a másik két faktor összegével. (optional)
     * @param optimize A kereső mire optimalizálja az útvonalakat. (optional, default to BEST)
     * @param walkProfile A séta sebességét meghatározó profil. (optional, default to MID)
     * @param numItineraries Legfeljebb hány útvonal szerepeljen a válaszban. (optional)
     * @return PlanTripResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A megadott paraméterekkel tervez megállóba útvonalat. </td><td>  -  </td></tr>
     </table>
     */
    public PlanTripResponse planAccess(Dialect dialect, String fromPlace, String toPlace, List<TraverseMode> mode, ApiVersion version, String appVersion, List<ReferencesSchema> includeReferences, String date, String time, Boolean shouldBuyTickets, Boolean showIntermediateStops, Boolean arriveBy, Boolean wheelchair, Double triangleSafetyFactor, Double triangleSlopeFactor, Double triangleTimeFactor, String optimize, WalkProfile walkProfile, Integer numItineraries) throws ApiException {
        ApiResponse<PlanTripResponse> localVarResp = planAccessWithHttpInfo(dialect, fromPlace, toPlace, mode, version, appVersion, includeReferences, date, time, shouldBuyTickets, showIntermediateStops, arriveBy, wheelchair, triangleSafetyFactor, triangleSlopeFactor, triangleTimeFactor, optimize, walkProfile, numItineraries);
        return localVarResp.getData();
    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param fromPlace Az indulási hely adatai &#x60;név::hely&#x60; formában. A &#x60;név&#x60; az adott hely tetszőleges neve, amely az útiterv kiindulási pontjának lesz a neve (&#x60;leg.from.name&#x60;). A &#x60;hely&#x60; lehet koordináta &#x60;lat,lon&#x60; formában, vagy a geocoder API által visszaadott &#x60;vertex&#x60; azonosítója. (required)
     * @param toPlace Az érkezési hely adatai &#x60;név::hely&#x60; formában. A &#x60;név&#x60; az adott hely tetszőleges neve, amely az útiterv érkezési pontjának lesz a neve (&#x60;leg.to.name&#x60;). A &#x60;hely&#x60; lehet koordináta &#x60;lat,lon&#x60; formában, vagy a geocoder API által visszaadott &#x60;vertex&#x60; azonosítója. (required)
     * @param mode A tervező milyen közlekedési módokat használjon. A kerékpár kölcsönzés a &#x60;BICYCLE,WALK&#x60; paraméterekkel kapcsolható be. (required)
     * @param version Az API verziója. (optional, default to 2)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param date A dátum, amikor a tervezés indul (&#x60;arriveBy&#x60; esetén érkezik). (optional)
     * @param time Az idő, amikor a tervezés indul (&#x60;arriveBy&#x60; esetén érkezik). (optional)
     * @param shouldBuyTickets Az első járműre szállás előtt történjen-e jegyvásárlás. (optional)
     * @param showIntermediateStops A válasz tartalmazza-e a járatok által érintett köztes megállókat is. (optional)
     * @param arriveBy Érkezési időre tervezzünk-e a megadott &#x60;date&#x60; és &#x60;time&#x60; paraméterrel. (optional)
     * @param wheelchair Az összes járat alacsonypadlós legyen-e. (optional)
     * @param triangleSafetyFactor Kerékpáros háromszög módú tervezés esetén mennyire számít a biztonság. 0 és 1 közötti szám, és 1-et kell kiadnia a másik két faktor összegével. (optional)
     * @param triangleSlopeFactor Kerékpáros háromszög módú tervezés esetén mennyire számít az útvonal síksága. 0 és 1 közötti szám, és 1-et kell kiadnia a másik két faktor összegével. (optional)
     * @param triangleTimeFactor Kerékpáros háromszög módú tervezés esetén mennyire számít a gyorsaság. 0 és 1 közötti szám, és 1-et kell kiadnia a másik két faktor összegével. (optional)
     * @param optimize A kereső mire optimalizálja az útvonalakat. (optional, default to BEST)
     * @param walkProfile A séta sebességét meghatározó profil. (optional, default to MID)
     * @param numItineraries Legfeljebb hány útvonal szerepeljen a válaszban. (optional)
     * @return ApiResponse&lt;PlanTripResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A megadott paraméterekkel tervez megállóba útvonalat. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PlanTripResponse> planAccessWithHttpInfo(Dialect dialect, String fromPlace, String toPlace, List<TraverseMode> mode, ApiVersion version, String appVersion, List<ReferencesSchema> includeReferences, String date, String time, Boolean shouldBuyTickets, Boolean showIntermediateStops, Boolean arriveBy, Boolean wheelchair, Double triangleSafetyFactor, Double triangleSlopeFactor, Double triangleTimeFactor, String optimize, WalkProfile walkProfile, Integer numItineraries) throws ApiException {
        okhttp3.Call localVarCall = planAccessValidateBeforeCall(dialect, fromPlace, toPlace, mode, version, appVersion, includeReferences, date, time, shouldBuyTickets, showIntermediateStops, arriveBy, wheelchair, triangleSafetyFactor, triangleSlopeFactor, triangleTimeFactor, optimize, walkProfile, numItineraries, null);
        Type localVarReturnType = new TypeToken<PlanTripResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param fromPlace Az indulási hely adatai &#x60;név::hely&#x60; formában. A &#x60;név&#x60; az adott hely tetszőleges neve, amely az útiterv kiindulási pontjának lesz a neve (&#x60;leg.from.name&#x60;). A &#x60;hely&#x60; lehet koordináta &#x60;lat,lon&#x60; formában, vagy a geocoder API által visszaadott &#x60;vertex&#x60; azonosítója. (required)
     * @param toPlace Az érkezési hely adatai &#x60;név::hely&#x60; formában. A &#x60;név&#x60; az adott hely tetszőleges neve, amely az útiterv érkezési pontjának lesz a neve (&#x60;leg.to.name&#x60;). A &#x60;hely&#x60; lehet koordináta &#x60;lat,lon&#x60; formában, vagy a geocoder API által visszaadott &#x60;vertex&#x60; azonosítója. (required)
     * @param mode A tervező milyen közlekedési módokat használjon. A kerékpár kölcsönzés a &#x60;BICYCLE,WALK&#x60; paraméterekkel kapcsolható be. (required)
     * @param version Az API verziója. (optional, default to 2)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param date A dátum, amikor a tervezés indul (&#x60;arriveBy&#x60; esetén érkezik). (optional)
     * @param time Az idő, amikor a tervezés indul (&#x60;arriveBy&#x60; esetén érkezik). (optional)
     * @param shouldBuyTickets Az első járműre szállás előtt történjen-e jegyvásárlás. (optional)
     * @param showIntermediateStops A válasz tartalmazza-e a járatok által érintett köztes megállókat is. (optional)
     * @param arriveBy Érkezési időre tervezzünk-e a megadott &#x60;date&#x60; és &#x60;time&#x60; paraméterrel. (optional)
     * @param wheelchair Az összes járat alacsonypadlós legyen-e. (optional)
     * @param triangleSafetyFactor Kerékpáros háromszög módú tervezés esetén mennyire számít a biztonság. 0 és 1 közötti szám, és 1-et kell kiadnia a másik két faktor összegével. (optional)
     * @param triangleSlopeFactor Kerékpáros háromszög módú tervezés esetén mennyire számít az útvonal síksága. 0 és 1 közötti szám, és 1-et kell kiadnia a másik két faktor összegével. (optional)
     * @param triangleTimeFactor Kerékpáros háromszög módú tervezés esetén mennyire számít a gyorsaság. 0 és 1 közötti szám, és 1-et kell kiadnia a másik két faktor összegével. (optional)
     * @param optimize A kereső mire optimalizálja az útvonalakat. (optional, default to BEST)
     * @param walkProfile A séta sebességét meghatározó profil. (optional, default to MID)
     * @param numItineraries Legfeljebb hány útvonal szerepeljen a válaszban. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A megadott paraméterekkel tervez megállóba útvonalat. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call planAccessAsync(Dialect dialect, String fromPlace, String toPlace, List<TraverseMode> mode, ApiVersion version, String appVersion, List<ReferencesSchema> includeReferences, String date, String time, Boolean shouldBuyTickets, Boolean showIntermediateStops, Boolean arriveBy, Boolean wheelchair, Double triangleSafetyFactor, Double triangleSlopeFactor, Double triangleTimeFactor, String optimize, WalkProfile walkProfile, Integer numItineraries, final ApiCallback<PlanTripResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = planAccessValidateBeforeCall(dialect, fromPlace, toPlace, mode, version, appVersion, includeReferences, date, time, shouldBuyTickets, showIntermediateStops, arriveBy, wheelchair, triangleSafetyFactor, triangleSlopeFactor, triangleTimeFactor, optimize, walkProfile, numItineraries, _callback);
        Type localVarReturnType = new TypeToken<PlanTripResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for planTrip
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param fromPlace Az indulási hely adatai &#x60;név::hely&#x60; formában. A &#x60;név&#x60; az adott hely tetszőleges neve, amely az útiterv kiindulási pontjának lesz a neve (&#x60;leg.from.name&#x60;). A &#x60;hely&#x60; lehet koordináta &#x60;lat,lon&#x60; formában, vagy a geocoder API által visszaadott &#x60;vertex&#x60; azonosítója. (required)
     * @param toPlace Az érkezési hely adatai &#x60;név::hely&#x60; formában. A &#x60;név&#x60; az adott hely tetszőleges neve, amely az útiterv érkezési pontjának lesz a neve (&#x60;leg.to.name&#x60;). A &#x60;hely&#x60; lehet koordináta &#x60;lat,lon&#x60; formában, vagy a geocoder API által visszaadott &#x60;vertex&#x60; azonosítója. (required)
     * @param mode A tervező milyen közlekedési módokat használjon. A kerékpár kölcsönzés a &#x60;BICYCLE,WALK&#x60; paraméterekkel kapcsolható be. (required)
     * @param version Az API verziója. (optional, default to 2)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param date A dátum, amikor a tervezés indul (&#x60;arriveBy&#x60; esetén érkezik). (optional)
     * @param time Az idő, amikor a tervezés indul (&#x60;arriveBy&#x60; esetén érkezik). (optional)
     * @param shouldBuyTickets Az első járműre szállás előtt történjen-e jegyvásárlás. (optional)
     * @param showIntermediateStops A válasz tartalmazza-e a járatok által érintett köztes megállókat is. (optional)
     * @param arriveBy Érkezési időre tervezzünk-e a megadott &#x60;date&#x60; és &#x60;time&#x60; paraméterrel. (optional)
     * @param wheelchair Az összes járat alacsonypadlós legyen-e. (optional)
     * @param triangleSafetyFactor Kerékpáros háromszög módú tervezés esetén mennyire számít a biztonság. 0 és 1 közötti szám, és 1-et kell kiadnia a másik két faktor összegével. (optional)
     * @param triangleSlopeFactor Kerékpáros háromszög módú tervezés esetén mennyire számít az útvonal síksága. 0 és 1 közötti szám, és 1-et kell kiadnia a másik két faktor összegével. (optional)
     * @param triangleTimeFactor Kerékpáros háromszög módú tervezés esetén mennyire számít a gyorsaság. 0 és 1 közötti szám, és 1-et kell kiadnia a másik két faktor összegével. (optional)
     * @param optimize A kereső mire optimalizálja az útvonalakat. (optional, default to BEST)
     * @param walkProfile A séta sebességét meghatározó profil. (optional, default to MID)
     * @param numItineraries Legfeljebb hány útvonal szerepeljen a válaszban. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A megadott paraméterekkel tervez útvonalat. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call planTripCall(Dialect dialect, String fromPlace, String toPlace, List<TraverseMode> mode, ApiVersion version, String appVersion, List<ReferencesSchema> includeReferences, String date, String time, Boolean shouldBuyTickets, Boolean showIntermediateStops, Boolean arriveBy, Boolean wheelchair, Double triangleSafetyFactor, Double triangleSlopeFactor, Double triangleTimeFactor, String optimize, WalkProfile walkProfile, Integer numItineraries, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/{dialect}/api/where/plan-trip"
            .replace("{" + "dialect" + "}", localVarApiClient.escapeString(dialect.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("version", version));
        }

        if (appVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("appVersion", appVersion));
        }

        if (includeReferences != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "includeReferences", includeReferences));
        }

        if (date != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("date", date));
        }

        if (time != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("time", time));
        }

        if (fromPlace != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromPlace", fromPlace));
        }

        if (toPlace != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("toPlace", toPlace));
        }

        if (mode != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "mode", mode));
        }

        if (shouldBuyTickets != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("shouldBuyTickets", shouldBuyTickets));
        }

        if (showIntermediateStops != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("showIntermediateStops", showIntermediateStops));
        }

        if (arriveBy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("arriveBy", arriveBy));
        }

        if (wheelchair != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("wheelchair", wheelchair));
        }

        if (triangleSafetyFactor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("triangleSafetyFactor", triangleSafetyFactor));
        }

        if (triangleSlopeFactor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("triangleSlopeFactor", triangleSlopeFactor));
        }

        if (triangleTimeFactor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("triangleTimeFactor", triangleTimeFactor));
        }

        if (optimize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("optimize", optimize));
        }

        if (walkProfile != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("walkProfile", walkProfile));
        }

        if (numItineraries != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("numItineraries", numItineraries));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyQuery" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call planTripValidateBeforeCall(Dialect dialect, String fromPlace, String toPlace, List<TraverseMode> mode, ApiVersion version, String appVersion, List<ReferencesSchema> includeReferences, String date, String time, Boolean shouldBuyTickets, Boolean showIntermediateStops, Boolean arriveBy, Boolean wheelchair, Double triangleSafetyFactor, Double triangleSlopeFactor, Double triangleTimeFactor, String optimize, WalkProfile walkProfile, Integer numItineraries, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'dialect' is set
        if (dialect == null) {
            throw new ApiException("Missing the required parameter 'dialect' when calling planTrip(Async)");
        }

        // verify the required parameter 'fromPlace' is set
        if (fromPlace == null) {
            throw new ApiException("Missing the required parameter 'fromPlace' when calling planTrip(Async)");
        }

        // verify the required parameter 'toPlace' is set
        if (toPlace == null) {
            throw new ApiException("Missing the required parameter 'toPlace' when calling planTrip(Async)");
        }

        // verify the required parameter 'mode' is set
        if (mode == null) {
            throw new ApiException("Missing the required parameter 'mode' when calling planTrip(Async)");
        }

        return planTripCall(dialect, fromPlace, toPlace, mode, version, appVersion, includeReferences, date, time, shouldBuyTickets, showIntermediateStops, arriveBy, wheelchair, triangleSafetyFactor, triangleSlopeFactor, triangleTimeFactor, optimize, walkProfile, numItineraries, _callback);

    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param fromPlace Az indulási hely adatai &#x60;név::hely&#x60; formában. A &#x60;név&#x60; az adott hely tetszőleges neve, amely az útiterv kiindulási pontjának lesz a neve (&#x60;leg.from.name&#x60;). A &#x60;hely&#x60; lehet koordináta &#x60;lat,lon&#x60; formában, vagy a geocoder API által visszaadott &#x60;vertex&#x60; azonosítója. (required)
     * @param toPlace Az érkezési hely adatai &#x60;név::hely&#x60; formában. A &#x60;név&#x60; az adott hely tetszőleges neve, amely az útiterv érkezési pontjának lesz a neve (&#x60;leg.to.name&#x60;). A &#x60;hely&#x60; lehet koordináta &#x60;lat,lon&#x60; formában, vagy a geocoder API által visszaadott &#x60;vertex&#x60; azonosítója. (required)
     * @param mode A tervező milyen közlekedési módokat használjon. A kerékpár kölcsönzés a &#x60;BICYCLE,WALK&#x60; paraméterekkel kapcsolható be. (required)
     * @param version Az API verziója. (optional, default to 2)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param date A dátum, amikor a tervezés indul (&#x60;arriveBy&#x60; esetén érkezik). (optional)
     * @param time Az idő, amikor a tervezés indul (&#x60;arriveBy&#x60; esetén érkezik). (optional)
     * @param shouldBuyTickets Az első járműre szállás előtt történjen-e jegyvásárlás. (optional)
     * @param showIntermediateStops A válasz tartalmazza-e a járatok által érintett köztes megállókat is. (optional)
     * @param arriveBy Érkezési időre tervezzünk-e a megadott &#x60;date&#x60; és &#x60;time&#x60; paraméterrel. (optional)
     * @param wheelchair Az összes járat alacsonypadlós legyen-e. (optional)
     * @param triangleSafetyFactor Kerékpáros háromszög módú tervezés esetén mennyire számít a biztonság. 0 és 1 közötti szám, és 1-et kell kiadnia a másik két faktor összegével. (optional)
     * @param triangleSlopeFactor Kerékpáros háromszög módú tervezés esetén mennyire számít az útvonal síksága. 0 és 1 közötti szám, és 1-et kell kiadnia a másik két faktor összegével. (optional)
     * @param triangleTimeFactor Kerékpáros háromszög módú tervezés esetén mennyire számít a gyorsaság. 0 és 1 közötti szám, és 1-et kell kiadnia a másik két faktor összegével. (optional)
     * @param optimize A kereső mire optimalizálja az útvonalakat. (optional, default to BEST)
     * @param walkProfile A séta sebességét meghatározó profil. (optional, default to MID)
     * @param numItineraries Legfeljebb hány útvonal szerepeljen a válaszban. (optional)
     * @return PlanTripResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A megadott paraméterekkel tervez útvonalat. </td><td>  -  </td></tr>
     </table>
     */
    public PlanTripResponse planTrip(Dialect dialect, String fromPlace, String toPlace, List<TraverseMode> mode, ApiVersion version, String appVersion, List<ReferencesSchema> includeReferences, String date, String time, Boolean shouldBuyTickets, Boolean showIntermediateStops, Boolean arriveBy, Boolean wheelchair, Double triangleSafetyFactor, Double triangleSlopeFactor, Double triangleTimeFactor, String optimize, WalkProfile walkProfile, Integer numItineraries) throws ApiException {
        ApiResponse<PlanTripResponse> localVarResp = planTripWithHttpInfo(dialect, fromPlace, toPlace, mode, version, appVersion, includeReferences, date, time, shouldBuyTickets, showIntermediateStops, arriveBy, wheelchair, triangleSafetyFactor, triangleSlopeFactor, triangleTimeFactor, optimize, walkProfile, numItineraries);
        return localVarResp.getData();
    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param fromPlace Az indulási hely adatai &#x60;név::hely&#x60; formában. A &#x60;név&#x60; az adott hely tetszőleges neve, amely az útiterv kiindulási pontjának lesz a neve (&#x60;leg.from.name&#x60;). A &#x60;hely&#x60; lehet koordináta &#x60;lat,lon&#x60; formában, vagy a geocoder API által visszaadott &#x60;vertex&#x60; azonosítója. (required)
     * @param toPlace Az érkezési hely adatai &#x60;név::hely&#x60; formában. A &#x60;név&#x60; az adott hely tetszőleges neve, amely az útiterv érkezési pontjának lesz a neve (&#x60;leg.to.name&#x60;). A &#x60;hely&#x60; lehet koordináta &#x60;lat,lon&#x60; formában, vagy a geocoder API által visszaadott &#x60;vertex&#x60; azonosítója. (required)
     * @param mode A tervező milyen közlekedési módokat használjon. A kerékpár kölcsönzés a &#x60;BICYCLE,WALK&#x60; paraméterekkel kapcsolható be. (required)
     * @param version Az API verziója. (optional, default to 2)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param date A dátum, amikor a tervezés indul (&#x60;arriveBy&#x60; esetén érkezik). (optional)
     * @param time Az idő, amikor a tervezés indul (&#x60;arriveBy&#x60; esetén érkezik). (optional)
     * @param shouldBuyTickets Az első járműre szállás előtt történjen-e jegyvásárlás. (optional)
     * @param showIntermediateStops A válasz tartalmazza-e a járatok által érintett köztes megállókat is. (optional)
     * @param arriveBy Érkezési időre tervezzünk-e a megadott &#x60;date&#x60; és &#x60;time&#x60; paraméterrel. (optional)
     * @param wheelchair Az összes járat alacsonypadlós legyen-e. (optional)
     * @param triangleSafetyFactor Kerékpáros háromszög módú tervezés esetén mennyire számít a biztonság. 0 és 1 közötti szám, és 1-et kell kiadnia a másik két faktor összegével. (optional)
     * @param triangleSlopeFactor Kerékpáros háromszög módú tervezés esetén mennyire számít az útvonal síksága. 0 és 1 közötti szám, és 1-et kell kiadnia a másik két faktor összegével. (optional)
     * @param triangleTimeFactor Kerékpáros háromszög módú tervezés esetén mennyire számít a gyorsaság. 0 és 1 közötti szám, és 1-et kell kiadnia a másik két faktor összegével. (optional)
     * @param optimize A kereső mire optimalizálja az útvonalakat. (optional, default to BEST)
     * @param walkProfile A séta sebességét meghatározó profil. (optional, default to MID)
     * @param numItineraries Legfeljebb hány útvonal szerepeljen a válaszban. (optional)
     * @return ApiResponse&lt;PlanTripResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A megadott paraméterekkel tervez útvonalat. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PlanTripResponse> planTripWithHttpInfo(Dialect dialect, String fromPlace, String toPlace, List<TraverseMode> mode, ApiVersion version, String appVersion, List<ReferencesSchema> includeReferences, String date, String time, Boolean shouldBuyTickets, Boolean showIntermediateStops, Boolean arriveBy, Boolean wheelchair, Double triangleSafetyFactor, Double triangleSlopeFactor, Double triangleTimeFactor, String optimize, WalkProfile walkProfile, Integer numItineraries) throws ApiException {
        okhttp3.Call localVarCall = planTripValidateBeforeCall(dialect, fromPlace, toPlace, mode, version, appVersion, includeReferences, date, time, shouldBuyTickets, showIntermediateStops, arriveBy, wheelchair, triangleSafetyFactor, triangleSlopeFactor, triangleTimeFactor, optimize, walkProfile, numItineraries, null);
        Type localVarReturnType = new TypeToken<PlanTripResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param fromPlace Az indulási hely adatai &#x60;név::hely&#x60; formában. A &#x60;név&#x60; az adott hely tetszőleges neve, amely az útiterv kiindulási pontjának lesz a neve (&#x60;leg.from.name&#x60;). A &#x60;hely&#x60; lehet koordináta &#x60;lat,lon&#x60; formában, vagy a geocoder API által visszaadott &#x60;vertex&#x60; azonosítója. (required)
     * @param toPlace Az érkezési hely adatai &#x60;név::hely&#x60; formában. A &#x60;név&#x60; az adott hely tetszőleges neve, amely az útiterv érkezési pontjának lesz a neve (&#x60;leg.to.name&#x60;). A &#x60;hely&#x60; lehet koordináta &#x60;lat,lon&#x60; formában, vagy a geocoder API által visszaadott &#x60;vertex&#x60; azonosítója. (required)
     * @param mode A tervező milyen közlekedési módokat használjon. A kerékpár kölcsönzés a &#x60;BICYCLE,WALK&#x60; paraméterekkel kapcsolható be. (required)
     * @param version Az API verziója. (optional, default to 2)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param date A dátum, amikor a tervezés indul (&#x60;arriveBy&#x60; esetén érkezik). (optional)
     * @param time Az idő, amikor a tervezés indul (&#x60;arriveBy&#x60; esetén érkezik). (optional)
     * @param shouldBuyTickets Az első járműre szállás előtt történjen-e jegyvásárlás. (optional)
     * @param showIntermediateStops A válasz tartalmazza-e a járatok által érintett köztes megállókat is. (optional)
     * @param arriveBy Érkezési időre tervezzünk-e a megadott &#x60;date&#x60; és &#x60;time&#x60; paraméterrel. (optional)
     * @param wheelchair Az összes járat alacsonypadlós legyen-e. (optional)
     * @param triangleSafetyFactor Kerékpáros háromszög módú tervezés esetén mennyire számít a biztonság. 0 és 1 közötti szám, és 1-et kell kiadnia a másik két faktor összegével. (optional)
     * @param triangleSlopeFactor Kerékpáros háromszög módú tervezés esetén mennyire számít az útvonal síksága. 0 és 1 közötti szám, és 1-et kell kiadnia a másik két faktor összegével. (optional)
     * @param triangleTimeFactor Kerékpáros háromszög módú tervezés esetén mennyire számít a gyorsaság. 0 és 1 közötti szám, és 1-et kell kiadnia a másik két faktor összegével. (optional)
     * @param optimize A kereső mire optimalizálja az útvonalakat. (optional, default to BEST)
     * @param walkProfile A séta sebességét meghatározó profil. (optional, default to MID)
     * @param numItineraries Legfeljebb hány útvonal szerepeljen a válaszban. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A megadott paraméterekkel tervez útvonalat. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call planTripAsync(Dialect dialect, String fromPlace, String toPlace, List<TraverseMode> mode, ApiVersion version, String appVersion, List<ReferencesSchema> includeReferences, String date, String time, Boolean shouldBuyTickets, Boolean showIntermediateStops, Boolean arriveBy, Boolean wheelchair, Double triangleSafetyFactor, Double triangleSlopeFactor, Double triangleTimeFactor, String optimize, WalkProfile walkProfile, Integer numItineraries, final ApiCallback<PlanTripResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = planTripValidateBeforeCall(dialect, fromPlace, toPlace, mode, version, appVersion, includeReferences, date, time, shouldBuyTickets, showIntermediateStops, arriveBy, wheelchair, triangleSafetyFactor, triangleSlopeFactor, triangleTimeFactor, optimize, walkProfile, numItineraries, _callback);
        Type localVarReturnType = new TypeToken<PlanTripResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for search
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param query Szűrőfeltétel, amire illesztve vannak a zavarok, járatok és megállók. (optional)
     * @param lat A látható térkép középpontjának szélessgéi koordinátája. (optional)
     * @param lon A látható térkép középpontjának hosszúsági koordinátája. (optional)
     * @param minResult A visszaadott elemek minimális száma. (optional, default to 5)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszaadja az olyan zavarokat, megállókat és járatokat, amelyek tulajdonságai illeszkednek a megadott szűrőrfeltételre. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchCall(Dialect dialect, String query, Float lat, Float lon, Integer minResult, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/{dialect}/api/where/search"
            .replace("{" + "dialect" + "}", localVarApiClient.escapeString(dialect.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (query != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("query", query));
        }

        if (lat != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("lat", lat));
        }

        if (lon != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("lon", lon));
        }

        if (minResult != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minResult", minResult));
        }

        if (appVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("appVersion", appVersion));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("version", version));
        }

        if (includeReferences != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "includeReferences", includeReferences));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyQuery" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchValidateBeforeCall(Dialect dialect, String query, Float lat, Float lon, Integer minResult, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'dialect' is set
        if (dialect == null) {
            throw new ApiException("Missing the required parameter 'dialect' when calling search(Async)");
        }

        return searchCall(dialect, query, lat, lon, minResult, appVersion, version, includeReferences, _callback);

    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param query Szűrőfeltétel, amire illesztve vannak a zavarok, járatok és megállók. (optional)
     * @param lat A látható térkép középpontjának szélessgéi koordinátája. (optional)
     * @param lon A látható térkép középpontjának hosszúsági koordinátája. (optional)
     * @param minResult A visszaadott elemek minimális száma. (optional, default to 5)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return SearchMethodResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszaadja az olyan zavarokat, megállókat és járatokat, amelyek tulajdonságai illeszkednek a megadott szűrőrfeltételre. </td><td>  -  </td></tr>
     </table>
     */
    public SearchMethodResponse search(Dialect dialect, String query, Float lat, Float lon, Integer minResult, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        ApiResponse<SearchMethodResponse> localVarResp = searchWithHttpInfo(dialect, query, lat, lon, minResult, appVersion, version, includeReferences);
        return localVarResp.getData();
    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param query Szűrőfeltétel, amire illesztve vannak a zavarok, járatok és megállók. (optional)
     * @param lat A látható térkép középpontjának szélessgéi koordinátája. (optional)
     * @param lon A látható térkép középpontjának hosszúsági koordinátája. (optional)
     * @param minResult A visszaadott elemek minimális száma. (optional, default to 5)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return ApiResponse&lt;SearchMethodResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszaadja az olyan zavarokat, megállókat és járatokat, amelyek tulajdonságai illeszkednek a megadott szűrőrfeltételre. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SearchMethodResponse> searchWithHttpInfo(Dialect dialect, String query, Float lat, Float lon, Integer minResult, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        okhttp3.Call localVarCall = searchValidateBeforeCall(dialect, query, lat, lon, minResult, appVersion, version, includeReferences, null);
        Type localVarReturnType = new TypeToken<SearchMethodResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param query Szűrőfeltétel, amire illesztve vannak a zavarok, járatok és megállók. (optional)
     * @param lat A látható térkép középpontjának szélessgéi koordinátája. (optional)
     * @param lon A látható térkép középpontjának hosszúsági koordinátája. (optional)
     * @param minResult A visszaadott elemek minimális száma. (optional, default to 5)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszaadja az olyan zavarokat, megállókat és járatokat, amelyek tulajdonságai illeszkednek a megadott szűrőrfeltételre. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchAsync(Dialect dialect, String query, Float lat, Float lon, Integer minResult, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback<SearchMethodResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchValidateBeforeCall(dialect, query, lat, lon, minResult, appVersion, version, includeReferences, _callback);
        Type localVarReturnType = new TypeToken<SearchMethodResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchAlerts
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param query A keresési feltétel, amit a zavar fejlécével, leírásával, vagy azonosítójával illesztünk. (optional)
     * @param start A keresés időintervallumának eleje epoch másodpercben. (optional)
     * @param end A keresési időintervallum vége epoch másodpercben. (optional)
     * @param minResult A visszaadott elemek minimális száma. (optional, default to 5)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszatér a &#x60;query&#x60; paraméterben megadott keresési feltételnek megfelelő zavarokkal, amik aktívak a megadott időintervallumnban. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchAlertsCall(Dialect dialect, String query, Long start, Long end, Integer minResult, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/{dialect}/api/where/alert-search"
            .replace("{" + "dialect" + "}", localVarApiClient.escapeString(dialect.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (query != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("query", query));
        }

        if (start != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("start", start));
        }

        if (end != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("end", end));
        }

        if (minResult != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minResult", minResult));
        }

        if (appVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("appVersion", appVersion));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("version", version));
        }

        if (includeReferences != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "includeReferences", includeReferences));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyQuery" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchAlertsValidateBeforeCall(Dialect dialect, String query, Long start, Long end, Integer minResult, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'dialect' is set
        if (dialect == null) {
            throw new ApiException("Missing the required parameter 'dialect' when calling searchAlerts(Async)");
        }

        return searchAlertsCall(dialect, query, start, end, minResult, appVersion, version, includeReferences, _callback);

    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param query A keresési feltétel, amit a zavar fejlécével, leírásával, vagy azonosítójával illesztünk. (optional)
     * @param start A keresés időintervallumának eleje epoch másodpercben. (optional)
     * @param end A keresési időintervallum vége epoch másodpercben. (optional)
     * @param minResult A visszaadott elemek minimális száma. (optional, default to 5)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return AlertSearchMethodResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszatér a &#x60;query&#x60; paraméterben megadott keresési feltételnek megfelelő zavarokkal, amik aktívak a megadott időintervallumnban. </td><td>  -  </td></tr>
     </table>
     */
    public AlertSearchMethodResponse searchAlerts(Dialect dialect, String query, Long start, Long end, Integer minResult, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        ApiResponse<AlertSearchMethodResponse> localVarResp = searchAlertsWithHttpInfo(dialect, query, start, end, minResult, appVersion, version, includeReferences);
        return localVarResp.getData();
    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param query A keresési feltétel, amit a zavar fejlécével, leírásával, vagy azonosítójával illesztünk. (optional)
     * @param start A keresés időintervallumának eleje epoch másodpercben. (optional)
     * @param end A keresési időintervallum vége epoch másodpercben. (optional)
     * @param minResult A visszaadott elemek minimális száma. (optional, default to 5)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @return ApiResponse&lt;AlertSearchMethodResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszatér a &#x60;query&#x60; paraméterben megadott keresési feltételnek megfelelő zavarokkal, amik aktívak a megadott időintervallumnban. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AlertSearchMethodResponse> searchAlertsWithHttpInfo(Dialect dialect, String query, Long start, Long end, Integer minResult, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences) throws ApiException {
        okhttp3.Call localVarCall = searchAlertsValidateBeforeCall(dialect, query, start, end, minResult, appVersion, version, includeReferences, null);
        Type localVarReturnType = new TypeToken<AlertSearchMethodResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param query A keresési feltétel, amit a zavar fejlécével, leírásával, vagy azonosítójával illesztünk. (optional)
     * @param start A keresés időintervallumának eleje epoch másodpercben. (optional)
     * @param end A keresési időintervallum vége epoch másodpercben. (optional)
     * @param minResult A visszaadott elemek minimális száma. (optional, default to 5)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszatér a &#x60;query&#x60; paraméterben megadott keresési feltételnek megfelelő zavarokkal, amik aktívak a megadott időintervallumnban. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchAlertsAsync(Dialect dialect, String query, Long start, Long end, Integer minResult, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, final ApiCallback<AlertSearchMethodResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchAlertsValidateBeforeCall(dialect, query, start, end, minResult, appVersion, version, includeReferences, _callback);
        Type localVarReturnType = new TypeToken<AlertSearchMethodResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchForOnboardDepartVehicles
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param onboardDepartPosition  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszatér az utas útvonalára illeszkedő járművekkel. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchForOnboardDepartVehiclesCall(Dialect dialect, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, List<OnboardDepartPosition> onboardDepartPosition, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = onboardDepartPosition;

        // create path and map variables
        String localVarPath = "/{dialect}/api/where/onboard-depart-search"
            .replace("{" + "dialect" + "}", localVarApiClient.escapeString(dialect.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (appVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("appVersion", appVersion));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("version", version));
        }

        if (includeReferences != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "includeReferences", includeReferences));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyQuery" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchForOnboardDepartVehiclesValidateBeforeCall(Dialect dialect, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, List<OnboardDepartPosition> onboardDepartPosition, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'dialect' is set
        if (dialect == null) {
            throw new ApiException("Missing the required parameter 'dialect' when calling searchForOnboardDepartVehicles(Async)");
        }

        return searchForOnboardDepartVehiclesCall(dialect, appVersion, version, includeReferences, onboardDepartPosition, _callback);

    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param onboardDepartPosition  (optional)
     * @return OnboardDepartSearchMethodResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszatér az utas útvonalára illeszkedő járművekkel. </td><td>  -  </td></tr>
     </table>
     */
    public OnboardDepartSearchMethodResponse searchForOnboardDepartVehicles(Dialect dialect, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, List<OnboardDepartPosition> onboardDepartPosition) throws ApiException {
        ApiResponse<OnboardDepartSearchMethodResponse> localVarResp = searchForOnboardDepartVehiclesWithHttpInfo(dialect, appVersion, version, includeReferences, onboardDepartPosition);
        return localVarResp.getData();
    }

    /**
     * 
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param onboardDepartPosition  (optional)
     * @return ApiResponse&lt;OnboardDepartSearchMethodResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszatér az utas útvonalára illeszkedő járművekkel. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<OnboardDepartSearchMethodResponse> searchForOnboardDepartVehiclesWithHttpInfo(Dialect dialect, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, List<OnboardDepartPosition> onboardDepartPosition) throws ApiException {
        okhttp3.Call localVarCall = searchForOnboardDepartVehiclesValidateBeforeCall(dialect, appVersion, version, includeReferences, onboardDepartPosition, null);
        Type localVarReturnType = new TypeToken<OnboardDepartSearchMethodResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param dialect Az API referenciáinak dialektusa. (required)
     * @param appVersion A kliensalkalmazás verziója. (optional)
     * @param version Az API verziója. (optional, default to 2)
     * @param includeReferences A referenciák típusát határozza meg. &#x60;true&#x60; vagy &#x60;COMPACT&#x60; esetén minden referencia szerepel, &#x60;false&#x60; esetén üres. &#x60;COMPACT&#x60; módban a route referenciák &#x60;description&#x60; mezője kihagyásra kerül. (optional)
     * @param onboardDepartPosition  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Visszatér az utas útvonalára illeszkedő járművekkel. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchForOnboardDepartVehiclesAsync(Dialect dialect, String appVersion, ApiVersion version, List<ReferencesSchema> includeReferences, List<OnboardDepartPosition> onboardDepartPosition, final ApiCallback<OnboardDepartSearchMethodResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchForOnboardDepartVehiclesValidateBeforeCall(dialect, appVersion, version, includeReferences, onboardDepartPosition, _callback);
        Type localVarReturnType = new TypeToken<OnboardDepartSearchMethodResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
