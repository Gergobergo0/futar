/*
 * realCity Query Server API
 * Specification for the realCity Query Server API.
 *
 * The version of the OpenAPI document: 1.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.DisplayedLeg;
import org.openapitools.client.model.Leg;
import org.openapitools.client.model.PatternStatistics;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A talált útvonalak listája.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-04-15T15:47:41.658152+02:00[Europe/Budapest]", comments = "Generator version: 7.12.0")
public class Itinerary {
  public static final String SERIALIZED_NAME_DURATION = "duration";
  @SerializedName(SERIALIZED_NAME_DURATION)
  @javax.annotation.Nullable
  private Long duration;

  public static final String SERIALIZED_NAME_START_TIME = "startTime";
  @SerializedName(SERIALIZED_NAME_START_TIME)
  @javax.annotation.Nullable
  private OffsetDateTime startTime;

  public static final String SERIALIZED_NAME_END_TIME = "endTime";
  @SerializedName(SERIALIZED_NAME_END_TIME)
  @javax.annotation.Nullable
  private OffsetDateTime endTime;

  public static final String SERIALIZED_NAME_WALK_TIME = "walkTime";
  @SerializedName(SERIALIZED_NAME_WALK_TIME)
  @javax.annotation.Nullable
  private Long walkTime;

  public static final String SERIALIZED_NAME_BIKE_TIME = "bikeTime";
  @SerializedName(SERIALIZED_NAME_BIKE_TIME)
  @javax.annotation.Nullable
  private Long bikeTime;

  public static final String SERIALIZED_NAME_TRANSIT_TIME = "transitTime";
  @SerializedName(SERIALIZED_NAME_TRANSIT_TIME)
  @javax.annotation.Nullable
  private Long transitTime;

  public static final String SERIALIZED_NAME_WAITING_TIME = "waitingTime";
  @SerializedName(SERIALIZED_NAME_WAITING_TIME)
  @javax.annotation.Nullable
  private Long waitingTime;

  public static final String SERIALIZED_NAME_BIKE_DISTANCE = "bikeDistance";
  @SerializedName(SERIALIZED_NAME_BIKE_DISTANCE)
  @javax.annotation.Nullable
  private Double bikeDistance;

  public static final String SERIALIZED_NAME_WALK_DISTANCE = "walkDistance";
  @SerializedName(SERIALIZED_NAME_WALK_DISTANCE)
  @javax.annotation.Nullable
  private Double walkDistance;

  public static final String SERIALIZED_NAME_WALK_LIMIT_EXCEEDED = "walkLimitExceeded";
  @SerializedName(SERIALIZED_NAME_WALK_LIMIT_EXCEEDED)
  @javax.annotation.Nullable
  private Boolean walkLimitExceeded;

  public static final String SERIALIZED_NAME_NOT_ALL_TICKETS_AVAILABLE = "notAllTicketsAvailable";
  @SerializedName(SERIALIZED_NAME_NOT_ALL_TICKETS_AVAILABLE)
  @javax.annotation.Nullable
  private Boolean notAllTicketsAvailable;

  public static final String SERIALIZED_NAME_BIKE_CATEGORY_DISTANCES = "bikeCategoryDistances";
  @SerializedName(SERIALIZED_NAME_BIKE_CATEGORY_DISTANCES)
  @javax.annotation.Nullable
  private Map<String, Double> bikeCategoryDistances = new HashMap<>();

  public static final String SERIALIZED_NAME_ELEVATION_LOST = "elevationLost";
  @SerializedName(SERIALIZED_NAME_ELEVATION_LOST)
  @javax.annotation.Nullable
  private Double elevationLost;

  public static final String SERIALIZED_NAME_ELEVATION_GAINED = "elevationGained";
  @SerializedName(SERIALIZED_NAME_ELEVATION_GAINED)
  @javax.annotation.Nullable
  private Double elevationGained;

  public static final String SERIALIZED_NAME_TRANSFERS = "transfers";
  @SerializedName(SERIALIZED_NAME_TRANSFERS)
  @javax.annotation.Nullable
  private Integer transfers;

  public static final String SERIALIZED_NAME_GENERALIZED_COST = "generalizedCost";
  @SerializedName(SERIALIZED_NAME_GENERALIZED_COST)
  @javax.annotation.Nullable
  private Integer generalizedCost;

  public static final String SERIALIZED_NAME_WAIT_TIME_ADJUSTED_GENERALIZED_COST = "waitTimeAdjustedGeneralizedCost";
  @SerializedName(SERIALIZED_NAME_WAIT_TIME_ADJUSTED_GENERALIZED_COST)
  @javax.annotation.Nullable
  private Integer waitTimeAdjustedGeneralizedCost;

  public static final String SERIALIZED_NAME_LEGS = "legs";
  @SerializedName(SERIALIZED_NAME_LEGS)
  @javax.annotation.Nullable
  private List<Leg> legs = new ArrayList<>();

  public static final String SERIALIZED_NAME_DISPLAYED_LEGS = "displayedLegs";
  @SerializedName(SERIALIZED_NAME_DISPLAYED_LEGS)
  @javax.annotation.Nullable
  private List<DisplayedLeg> displayedLegs = new ArrayList<>();

  public static final String SERIALIZED_NAME_TOO_SLOPED = "tooSloped";
  @SerializedName(SERIALIZED_NAME_TOO_SLOPED)
  @javax.annotation.Nullable
  private Boolean tooSloped;

  public static final String SERIALIZED_NAME_PATTERN_ITINERARIES = "patternItineraries";
  @SerializedName(SERIALIZED_NAME_PATTERN_ITINERARIES)
  @javax.annotation.Nullable
  private List<Itinerary> patternItineraries = new ArrayList<>();

  public static final String SERIALIZED_NAME_PATTERN_FREQUENCY = "patternFrequency";
  @SerializedName(SERIALIZED_NAME_PATTERN_FREQUENCY)
  @javax.annotation.Nullable
  private PatternStatistics patternFrequency;

  public static final String SERIALIZED_NAME_PATTERN_DURATION = "patternDuration";
  @SerializedName(SERIALIZED_NAME_PATTERN_DURATION)
  @javax.annotation.Nullable
  private PatternStatistics patternDuration;

  public static final String SERIALIZED_NAME_DISPLAY_PRODUCT_RECOMMENDATION = "displayProductRecommendation";
  @SerializedName(SERIALIZED_NAME_DISPLAY_PRODUCT_RECOMMENDATION)
  @javax.annotation.Nullable
  private Boolean displayProductRecommendation;

  public Itinerary() {
  }

  public Itinerary duration(@javax.annotation.Nullable Long duration) {
    this.duration = duration;
    return this;
  }

  /**
   * Az útvonal hossza másodpercben.
   * @return duration
   */
  @javax.annotation.Nullable
  public Long getDuration() {
    return duration;
  }

  public void setDuration(@javax.annotation.Nullable Long duration) {
    this.duration = duration;
  }


  public Itinerary startTime(@javax.annotation.Nullable OffsetDateTime startTime) {
    this.startTime = startTime;
    return this;
  }

  /**
   * Az indulási időpont ezredmásodpercben.
   * @return startTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getStartTime() {
    return startTime;
  }

  public void setStartTime(@javax.annotation.Nullable OffsetDateTime startTime) {
    this.startTime = startTime;
  }


  public Itinerary endTime(@javax.annotation.Nullable OffsetDateTime endTime) {
    this.endTime = endTime;
    return this;
  }

  /**
   * Az érkezési időpont ezredmásodpercben.
   * @return endTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getEndTime() {
    return endTime;
  }

  public void setEndTime(@javax.annotation.Nullable OffsetDateTime endTime) {
    this.endTime = endTime;
  }


  public Itinerary walkTime(@javax.annotation.Nullable Long walkTime) {
    this.walkTime = walkTime;
    return this;
  }

  /**
   * Sétálási idő az útvonalon másodpercben.
   * @return walkTime
   */
  @javax.annotation.Nullable
  public Long getWalkTime() {
    return walkTime;
  }

  public void setWalkTime(@javax.annotation.Nullable Long walkTime) {
    this.walkTime = walkTime;
  }


  public Itinerary bikeTime(@javax.annotation.Nullable Long bikeTime) {
    this.bikeTime = bikeTime;
    return this;
  }

  /**
   * Kerékpározási idő az útvonalon másodpercben.
   * @return bikeTime
   */
  @javax.annotation.Nullable
  public Long getBikeTime() {
    return bikeTime;
  }

  public void setBikeTime(@javax.annotation.Nullable Long bikeTime) {
    this.bikeTime = bikeTime;
  }


  public Itinerary transitTime(@javax.annotation.Nullable Long transitTime) {
    this.transitTime = transitTime;
    return this;
  }

  /**
   * Járművön töltött idő az útvonalon másodpercben.
   * @return transitTime
   */
  @javax.annotation.Nullable
  public Long getTransitTime() {
    return transitTime;
  }

  public void setTransitTime(@javax.annotation.Nullable Long transitTime) {
    this.transitTime = transitTime;
  }


  public Itinerary waitingTime(@javax.annotation.Nullable Long waitingTime) {
    this.waitingTime = waitingTime;
    return this;
  }

  /**
   * Várakozási idő járműre az útvonalon másodpercben.
   * @return waitingTime
   */
  @javax.annotation.Nullable
  public Long getWaitingTime() {
    return waitingTime;
  }

  public void setWaitingTime(@javax.annotation.Nullable Long waitingTime) {
    this.waitingTime = waitingTime;
  }


  public Itinerary bikeDistance(@javax.annotation.Nullable Double bikeDistance) {
    this.bikeDistance = bikeDistance;
    return this;
  }

  /**
   * Kerékpározási távolság az útvonalon méterben.
   * @return bikeDistance
   */
  @javax.annotation.Nullable
  public Double getBikeDistance() {
    return bikeDistance;
  }

  public void setBikeDistance(@javax.annotation.Nullable Double bikeDistance) {
    this.bikeDistance = bikeDistance;
  }


  public Itinerary walkDistance(@javax.annotation.Nullable Double walkDistance) {
    this.walkDistance = walkDistance;
    return this;
  }

  /**
   * Sétálási távolság az útvonalon méterben.
   * @return walkDistance
   */
  @javax.annotation.Nullable
  public Double getWalkDistance() {
    return walkDistance;
  }

  public void setWalkDistance(@javax.annotation.Nullable Double walkDistance) {
    this.walkDistance = walkDistance;
  }


  public Itinerary walkLimitExceeded(@javax.annotation.Nullable Boolean walkLimitExceeded) {
    this.walkLimitExceeded = walkLimitExceeded;
    return this;
  }

  /**
   * Jelzi, hogy a sétálási limit túl lett lépve az útitervben.
   * @return walkLimitExceeded
   */
  @javax.annotation.Nullable
  public Boolean getWalkLimitExceeded() {
    return walkLimitExceeded;
  }

  public void setWalkLimitExceeded(@javax.annotation.Nullable Boolean walkLimitExceeded) {
    this.walkLimitExceeded = walkLimitExceeded;
  }


  public Itinerary notAllTicketsAvailable(@javax.annotation.Nullable Boolean notAllTicketsAvailable) {
    this.notAllTicketsAvailable = notAllTicketsAvailable;
    return this;
  }

  /**
   * Jelzi, hogy a visszaadott útvonalak tartalmazhatnak olyan járatokat (pl.: vonatok), amire a terv során érintett jegyértékesítési helyen nem lehet jegyet váltani.
   * @return notAllTicketsAvailable
   */
  @javax.annotation.Nullable
  public Boolean getNotAllTicketsAvailable() {
    return notAllTicketsAvailable;
  }

  public void setNotAllTicketsAvailable(@javax.annotation.Nullable Boolean notAllTicketsAvailable) {
    this.notAllTicketsAvailable = notAllTicketsAvailable;
  }


  public Itinerary bikeCategoryDistances(@javax.annotation.Nullable Map<String, Double> bikeCategoryDistances) {
    this.bikeCategoryDistances = bikeCategoryDistances;
    return this;
  }

  public Itinerary putBikeCategoryDistancesItem(String key, Double bikeCategoryDistancesItem) {
    if (this.bikeCategoryDistances == null) {
      this.bikeCategoryDistances = new HashMap<>();
    }
    this.bikeCategoryDistances.put(key, bikeCategoryDistancesItem);
    return this;
  }

  /**
   * Az útiterv során hány méter kerékpározást tartalmaztak az egyes kategóriák. Az objektum kulcsai a kategóriák (&#x60;BikeStreetCategory&#x60;).
   * @return bikeCategoryDistances
   */
  @javax.annotation.Nullable
  public Map<String, Double> getBikeCategoryDistances() {
    return bikeCategoryDistances;
  }

  public void setBikeCategoryDistances(@javax.annotation.Nullable Map<String, Double> bikeCategoryDistances) {
    this.bikeCategoryDistances = bikeCategoryDistances;
  }


  public Itinerary elevationLost(@javax.annotation.Nullable Double elevationLost) {
    this.elevationLost = elevationLost;
    return this;
  }

  /**
   * Az útiterv során hány métert süllyed az útvonal.
   * @return elevationLost
   */
  @javax.annotation.Nullable
  public Double getElevationLost() {
    return elevationLost;
  }

  public void setElevationLost(@javax.annotation.Nullable Double elevationLost) {
    this.elevationLost = elevationLost;
  }


  public Itinerary elevationGained(@javax.annotation.Nullable Double elevationGained) {
    this.elevationGained = elevationGained;
    return this;
  }

  /**
   * Az útiterv során hány métert emelkedik az útvonal.
   * @return elevationGained
   */
  @javax.annotation.Nullable
  public Double getElevationGained() {
    return elevationGained;
  }

  public void setElevationGained(@javax.annotation.Nullable Double elevationGained) {
    this.elevationGained = elevationGained;
  }


  public Itinerary transfers(@javax.annotation.Nullable Integer transfers) {
    this.transfers = transfers;
    return this;
  }

  /**
   * Átszállások száma az útitervben.
   * @return transfers
   */
  @javax.annotation.Nullable
  public Integer getTransfers() {
    return transfers;
  }

  public void setTransfers(@javax.annotation.Nullable Integer transfers) {
    this.transfers = transfers;
  }


  public Itinerary generalizedCost(@javax.annotation.Nullable Integer generalizedCost) {
    this.generalizedCost = generalizedCost;
    return this;
  }

  /**
   * Az utazástervező algoritmus által használt súly.
   * @return generalizedCost
   */
  @javax.annotation.Nullable
  public Integer getGeneralizedCost() {
    return generalizedCost;
  }

  public void setGeneralizedCost(@javax.annotation.Nullable Integer generalizedCost) {
    this.generalizedCost = generalizedCost;
  }


  public Itinerary waitTimeAdjustedGeneralizedCost(@javax.annotation.Nullable Integer waitTimeAdjustedGeneralizedCost) {
    this.waitTimeAdjustedGeneralizedCost = waitTimeAdjustedGeneralizedCost;
    return this;
  }

  /**
   * A várakozási idővel igazított súly.
   * @return waitTimeAdjustedGeneralizedCost
   */
  @javax.annotation.Nullable
  public Integer getWaitTimeAdjustedGeneralizedCost() {
    return waitTimeAdjustedGeneralizedCost;
  }

  public void setWaitTimeAdjustedGeneralizedCost(@javax.annotation.Nullable Integer waitTimeAdjustedGeneralizedCost) {
    this.waitTimeAdjustedGeneralizedCost = waitTimeAdjustedGeneralizedCost;
  }


  public Itinerary legs(@javax.annotation.Nullable List<Leg> legs) {
    this.legs = legs;
    return this;
  }

  public Itinerary addLegsItem(Leg legsItem) {
    if (this.legs == null) {
      this.legs = new ArrayList<>();
    }
    this.legs.add(legsItem);
    return this;
  }

  /**
   * Az útiterv lábai (részei).
   * @return legs
   */
  @javax.annotation.Nullable
  public List<Leg> getLegs() {
    return legs;
  }

  public void setLegs(@javax.annotation.Nullable List<Leg> legs) {
    this.legs = legs;
  }


  public Itinerary displayedLegs(@javax.annotation.Nullable List<DisplayedLeg> displayedLegs) {
    this.displayedLegs = displayedLegs;
    return this;
  }

  public Itinerary addDisplayedLegsItem(DisplayedLeg displayedLegsItem) {
    if (this.displayedLegs == null) {
      this.displayedLegs = new ArrayList<>();
    }
    this.displayedLegs.add(displayedLegsItem);
    return this;
  }

  /**
   * Az útiterv kivonatos megjelenítéséhez használható  lábak és adatok.
   * @return displayedLegs
   */
  @javax.annotation.Nullable
  public List<DisplayedLeg> getDisplayedLegs() {
    return displayedLegs;
  }

  public void setDisplayedLegs(@javax.annotation.Nullable List<DisplayedLeg> displayedLegs) {
    this.displayedLegs = displayedLegs;
  }


  public Itinerary tooSloped(@javax.annotation.Nullable Boolean tooSloped) {
    this.tooSloped = tooSloped;
    return this;
  }

  /**
   * Jelzi, ha az útvonal meredekebb, mint a paraméterekben kért.
   * @return tooSloped
   */
  @javax.annotation.Nullable
  public Boolean getTooSloped() {
    return tooSloped;
  }

  public void setTooSloped(@javax.annotation.Nullable Boolean tooSloped) {
    this.tooSloped = tooSloped;
  }


  public Itinerary patternItineraries(@javax.annotation.Nullable List<Itinerary> patternItineraries) {
    this.patternItineraries = patternItineraries;
    return this;
  }

  public Itinerary addPatternItinerariesItem(Itinerary patternItinerariesItem) {
    if (this.patternItineraries == null) {
      this.patternItineraries = new ArrayList<>();
    }
    this.patternItineraries.add(patternItinerariesItem);
    return this;
  }

  /**
   * Útitervminták engedélyezése esetén a mintába tartozó útitervek.
   * @return patternItineraries
   */
  @javax.annotation.Nullable
  public List<Itinerary> getPatternItineraries() {
    return patternItineraries;
  }

  public void setPatternItineraries(@javax.annotation.Nullable List<Itinerary> patternItineraries) {
    this.patternItineraries = patternItineraries;
  }


  public Itinerary patternFrequency(@javax.annotation.Nullable PatternStatistics patternFrequency) {
    this.patternFrequency = patternFrequency;
    return this;
  }

  /**
   * Get patternFrequency
   * @return patternFrequency
   */
  @javax.annotation.Nullable
  public PatternStatistics getPatternFrequency() {
    return patternFrequency;
  }

  public void setPatternFrequency(@javax.annotation.Nullable PatternStatistics patternFrequency) {
    this.patternFrequency = patternFrequency;
  }


  public Itinerary patternDuration(@javax.annotation.Nullable PatternStatistics patternDuration) {
    this.patternDuration = patternDuration;
    return this;
  }

  /**
   * Get patternDuration
   * @return patternDuration
   */
  @javax.annotation.Nullable
  public PatternStatistics getPatternDuration() {
    return patternDuration;
  }

  public void setPatternDuration(@javax.annotation.Nullable PatternStatistics patternDuration) {
    this.patternDuration = patternDuration;
  }


  public Itinerary displayProductRecommendation(@javax.annotation.Nullable Boolean displayProductRecommendation) {
    this.displayProductRecommendation = displayProductRecommendation;
    return this;
  }

  /**
   * Jelzi, ha az útvonalhoz kell termékajánlást mutatni.
   * @return displayProductRecommendation
   */
  @javax.annotation.Nullable
  public Boolean getDisplayProductRecommendation() {
    return displayProductRecommendation;
  }

  public void setDisplayProductRecommendation(@javax.annotation.Nullable Boolean displayProductRecommendation) {
    this.displayProductRecommendation = displayProductRecommendation;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Itinerary itinerary = (Itinerary) o;
    return Objects.equals(this.duration, itinerary.duration) &&
        Objects.equals(this.startTime, itinerary.startTime) &&
        Objects.equals(this.endTime, itinerary.endTime) &&
        Objects.equals(this.walkTime, itinerary.walkTime) &&
        Objects.equals(this.bikeTime, itinerary.bikeTime) &&
        Objects.equals(this.transitTime, itinerary.transitTime) &&
        Objects.equals(this.waitingTime, itinerary.waitingTime) &&
        Objects.equals(this.bikeDistance, itinerary.bikeDistance) &&
        Objects.equals(this.walkDistance, itinerary.walkDistance) &&
        Objects.equals(this.walkLimitExceeded, itinerary.walkLimitExceeded) &&
        Objects.equals(this.notAllTicketsAvailable, itinerary.notAllTicketsAvailable) &&
        Objects.equals(this.bikeCategoryDistances, itinerary.bikeCategoryDistances) &&
        Objects.equals(this.elevationLost, itinerary.elevationLost) &&
        Objects.equals(this.elevationGained, itinerary.elevationGained) &&
        Objects.equals(this.transfers, itinerary.transfers) &&
        Objects.equals(this.generalizedCost, itinerary.generalizedCost) &&
        Objects.equals(this.waitTimeAdjustedGeneralizedCost, itinerary.waitTimeAdjustedGeneralizedCost) &&
        Objects.equals(this.legs, itinerary.legs) &&
        Objects.equals(this.displayedLegs, itinerary.displayedLegs) &&
        Objects.equals(this.tooSloped, itinerary.tooSloped) &&
        Objects.equals(this.patternItineraries, itinerary.patternItineraries) &&
        Objects.equals(this.patternFrequency, itinerary.patternFrequency) &&
        Objects.equals(this.patternDuration, itinerary.patternDuration) &&
        Objects.equals(this.displayProductRecommendation, itinerary.displayProductRecommendation);
  }

  @Override
  public int hashCode() {
    return Objects.hash(duration, startTime, endTime, walkTime, bikeTime, transitTime, waitingTime, bikeDistance, walkDistance, walkLimitExceeded, notAllTicketsAvailable, bikeCategoryDistances, elevationLost, elevationGained, transfers, generalizedCost, waitTimeAdjustedGeneralizedCost, legs, displayedLegs, tooSloped, patternItineraries, patternFrequency, patternDuration, displayProductRecommendation);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Itinerary {\n");
    sb.append("    duration: ").append(toIndentedString(duration)).append("\n");
    sb.append("    startTime: ").append(toIndentedString(startTime)).append("\n");
    sb.append("    endTime: ").append(toIndentedString(endTime)).append("\n");
    sb.append("    walkTime: ").append(toIndentedString(walkTime)).append("\n");
    sb.append("    bikeTime: ").append(toIndentedString(bikeTime)).append("\n");
    sb.append("    transitTime: ").append(toIndentedString(transitTime)).append("\n");
    sb.append("    waitingTime: ").append(toIndentedString(waitingTime)).append("\n");
    sb.append("    bikeDistance: ").append(toIndentedString(bikeDistance)).append("\n");
    sb.append("    walkDistance: ").append(toIndentedString(walkDistance)).append("\n");
    sb.append("    walkLimitExceeded: ").append(toIndentedString(walkLimitExceeded)).append("\n");
    sb.append("    notAllTicketsAvailable: ").append(toIndentedString(notAllTicketsAvailable)).append("\n");
    sb.append("    bikeCategoryDistances: ").append(toIndentedString(bikeCategoryDistances)).append("\n");
    sb.append("    elevationLost: ").append(toIndentedString(elevationLost)).append("\n");
    sb.append("    elevationGained: ").append(toIndentedString(elevationGained)).append("\n");
    sb.append("    transfers: ").append(toIndentedString(transfers)).append("\n");
    sb.append("    generalizedCost: ").append(toIndentedString(generalizedCost)).append("\n");
    sb.append("    waitTimeAdjustedGeneralizedCost: ").append(toIndentedString(waitTimeAdjustedGeneralizedCost)).append("\n");
    sb.append("    legs: ").append(toIndentedString(legs)).append("\n");
    sb.append("    displayedLegs: ").append(toIndentedString(displayedLegs)).append("\n");
    sb.append("    tooSloped: ").append(toIndentedString(tooSloped)).append("\n");
    sb.append("    patternItineraries: ").append(toIndentedString(patternItineraries)).append("\n");
    sb.append("    patternFrequency: ").append(toIndentedString(patternFrequency)).append("\n");
    sb.append("    patternDuration: ").append(toIndentedString(patternDuration)).append("\n");
    sb.append("    displayProductRecommendation: ").append(toIndentedString(displayProductRecommendation)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("duration");
    openapiFields.add("startTime");
    openapiFields.add("endTime");
    openapiFields.add("walkTime");
    openapiFields.add("bikeTime");
    openapiFields.add("transitTime");
    openapiFields.add("waitingTime");
    openapiFields.add("bikeDistance");
    openapiFields.add("walkDistance");
    openapiFields.add("walkLimitExceeded");
    openapiFields.add("notAllTicketsAvailable");
    openapiFields.add("bikeCategoryDistances");
    openapiFields.add("elevationLost");
    openapiFields.add("elevationGained");
    openapiFields.add("transfers");
    openapiFields.add("generalizedCost");
    openapiFields.add("waitTimeAdjustedGeneralizedCost");
    openapiFields.add("legs");
    openapiFields.add("displayedLegs");
    openapiFields.add("tooSloped");
    openapiFields.add("patternItineraries");
    openapiFields.add("patternFrequency");
    openapiFields.add("patternDuration");
    openapiFields.add("displayProductRecommendation");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Itinerary
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Itinerary.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Itinerary is not found in the empty JSON string", Itinerary.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Itinerary.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Itinerary` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("legs") != null && !jsonObj.get("legs").isJsonNull()) {
        JsonArray jsonArraylegs = jsonObj.getAsJsonArray("legs");
        if (jsonArraylegs != null) {
          // ensure the json data is an array
          if (!jsonObj.get("legs").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `legs` to be an array in the JSON string but got `%s`", jsonObj.get("legs").toString()));
          }

          // validate the optional field `legs` (array)
          for (int i = 0; i < jsonArraylegs.size(); i++) {
            Leg.validateJsonElement(jsonArraylegs.get(i));
          };
        }
      }
      if (jsonObj.get("displayedLegs") != null && !jsonObj.get("displayedLegs").isJsonNull()) {
        JsonArray jsonArraydisplayedLegs = jsonObj.getAsJsonArray("displayedLegs");
        if (jsonArraydisplayedLegs != null) {
          // ensure the json data is an array
          if (!jsonObj.get("displayedLegs").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `displayedLegs` to be an array in the JSON string but got `%s`", jsonObj.get("displayedLegs").toString()));
          }

          // validate the optional field `displayedLegs` (array)
          for (int i = 0; i < jsonArraydisplayedLegs.size(); i++) {
            DisplayedLeg.validateJsonElement(jsonArraydisplayedLegs.get(i));
          };
        }
      }
      if (jsonObj.get("patternItineraries") != null && !jsonObj.get("patternItineraries").isJsonNull()) {
        JsonArray jsonArraypatternItineraries = jsonObj.getAsJsonArray("patternItineraries");
        if (jsonArraypatternItineraries != null) {
          // ensure the json data is an array
          if (!jsonObj.get("patternItineraries").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `patternItineraries` to be an array in the JSON string but got `%s`", jsonObj.get("patternItineraries").toString()));
          }

          // validate the optional field `patternItineraries` (array)
          for (int i = 0; i < jsonArraypatternItineraries.size(); i++) {
            Itinerary.validateJsonElement(jsonArraypatternItineraries.get(i));
          };
        }
      }
      // validate the optional field `patternFrequency`
      if (jsonObj.get("patternFrequency") != null && !jsonObj.get("patternFrequency").isJsonNull()) {
        PatternStatistics.validateJsonElement(jsonObj.get("patternFrequency"));
      }
      // validate the optional field `patternDuration`
      if (jsonObj.get("patternDuration") != null && !jsonObj.get("patternDuration").isJsonNull()) {
        PatternStatistics.validateJsonElement(jsonObj.get("patternDuration"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Itinerary.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Itinerary' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Itinerary> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Itinerary.class));

       return (TypeAdapter<T>) new TypeAdapter<Itinerary>() {
           @Override
           public void write(JsonWriter out, Itinerary value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Itinerary read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Itinerary given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Itinerary
   * @throws IOException if the JSON string is invalid with respect to Itinerary
   */
  public static Itinerary fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Itinerary.class);
  }

  /**
   * Convert an instance of Itinerary to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

