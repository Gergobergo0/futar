/*
 * realCity Query Server API
 * Specification for the realCity Query Server API.
 *
 * The version of the OpenAPI document: 1.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A lekért adat.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-04-15T15:47:41.658152+02:00[Europe/Budapest]", comments = "Generator version: 7.12.0")
public class TransitMetadata {
  public static final String SERIALIZED_NAME_TIME = "time";
  @SerializedName(SERIALIZED_NAME_TIME)
  @javax.annotation.Nullable
  private Long time;

  public static final String SERIALIZED_NAME_TIME_ZONE = "timeZone";
  @SerializedName(SERIALIZED_NAME_TIME_ZONE)
  @javax.annotation.Nullable
  private String timeZone;

  public static final String SERIALIZED_NAME_READABLE_TIME = "readableTime";
  @SerializedName(SERIALIZED_NAME_READABLE_TIME)
  @javax.annotation.Nullable
  private String readableTime;

  public static final String SERIALIZED_NAME_VALIDITY_START = "validityStart";
  @SerializedName(SERIALIZED_NAME_VALIDITY_START)
  @javax.annotation.Nullable
  private String validityStart;

  public static final String SERIALIZED_NAME_VALIDITY_END = "validityEnd";
  @SerializedName(SERIALIZED_NAME_VALIDITY_END)
  @javax.annotation.Nullable
  private String validityEnd;

  public static final String SERIALIZED_NAME_COMPLETE_VALIDITY_START = "completeValidityStart";
  @SerializedName(SERIALIZED_NAME_COMPLETE_VALIDITY_START)
  @javax.annotation.Nullable
  private String completeValidityStart;

  public static final String SERIALIZED_NAME_COMPLETE_VALIDITY_END = "completeValidityEnd";
  @SerializedName(SERIALIZED_NAME_COMPLETE_VALIDITY_END)
  @javax.annotation.Nullable
  private String completeValidityEnd;

  public static final String SERIALIZED_NAME_LOWER_LEFT_LATITUDE = "lowerLeftLatitude";
  @SerializedName(SERIALIZED_NAME_LOWER_LEFT_LATITUDE)
  @javax.annotation.Nullable
  private Double lowerLeftLatitude;

  public static final String SERIALIZED_NAME_LOWER_LEFT_LONGITUDE = "lowerLeftLongitude";
  @SerializedName(SERIALIZED_NAME_LOWER_LEFT_LONGITUDE)
  @javax.annotation.Nullable
  private Double lowerLeftLongitude;

  public static final String SERIALIZED_NAME_UPPER_RIGHT_LATITUDE = "upperRightLatitude";
  @SerializedName(SERIALIZED_NAME_UPPER_RIGHT_LATITUDE)
  @javax.annotation.Nullable
  private Double upperRightLatitude;

  public static final String SERIALIZED_NAME_UPPER_RIGHT_LONGITUDE = "upperRightLongitude";
  @SerializedName(SERIALIZED_NAME_UPPER_RIGHT_LONGITUDE)
  @javax.annotation.Nullable
  private Double upperRightLongitude;

  public static final String SERIALIZED_NAME_BOUNDING_POLY_LINE = "boundingPolyLine";
  @SerializedName(SERIALIZED_NAME_BOUNDING_POLY_LINE)
  @javax.annotation.Nullable
  private String boundingPolyLine;

  public static final String SERIALIZED_NAME_ALERT_IDS = "alertIds";
  @SerializedName(SERIALIZED_NAME_ALERT_IDS)
  @javax.annotation.Nullable
  private List<String> alertIds = new ArrayList<>();

  public static final String SERIALIZED_NAME_FEED_IDS = "feedIds";
  @SerializedName(SERIALIZED_NAME_FEED_IDS)
  @javax.annotation.Nullable
  private List<String> feedIds = new ArrayList<>();

  public static final String SERIALIZED_NAME_DAY_TYPES = "dayTypes";
  @SerializedName(SERIALIZED_NAME_DAY_TYPES)
  @javax.annotation.Nullable
  private Map<String, String> dayTypes = new HashMap<>();

  public TransitMetadata() {
  }

  public TransitMetadata time(@javax.annotation.Nullable Long time) {
    this.time = time;
    return this;
  }

  /**
   * Aktuális szerveridő ezredmásodpercben.
   * @return time
   */
  @javax.annotation.Nullable
  public Long getTime() {
    return time;
  }

  public void setTime(@javax.annotation.Nullable Long time) {
    this.time = time;
  }


  public TransitMetadata timeZone(@javax.annotation.Nullable String timeZone) {
    this.timeZone = timeZone;
    return this;
  }

  /**
   * A szerver tranzit adatainak időzónája.
   * @return timeZone
   */
  @javax.annotation.Nullable
  public String getTimeZone() {
    return timeZone;
  }

  public void setTimeZone(@javax.annotation.Nullable String timeZone) {
    this.timeZone = timeZone;
  }


  public TransitMetadata readableTime(@javax.annotation.Nullable String readableTime) {
    this.readableTime = readableTime;
    return this;
  }

  /**
   * A szerver ideje ISO8601 formátumban.
   * @return readableTime
   */
  @javax.annotation.Nullable
  public String getReadableTime() {
    return readableTime;
  }

  public void setReadableTime(@javax.annotation.Nullable String readableTime) {
    this.readableTime = readableTime;
  }


  public TransitMetadata validityStart(@javax.annotation.Nullable String validityStart) {
    this.validityStart = validityStart;
    return this;
  }

  /**
   * A szerveren található adatok érvényességének kezdete.
   * @return validityStart
   */
  @javax.annotation.Nullable
  public String getValidityStart() {
    return validityStart;
  }

  public void setValidityStart(@javax.annotation.Nullable String validityStart) {
    this.validityStart = validityStart;
  }


  public TransitMetadata validityEnd(@javax.annotation.Nullable String validityEnd) {
    this.validityEnd = validityEnd;
    return this;
  }

  /**
   * A szerveren található adatok érvényességének vége.
   * @return validityEnd
   */
  @javax.annotation.Nullable
  public String getValidityEnd() {
    return validityEnd;
  }

  public void setValidityEnd(@javax.annotation.Nullable String validityEnd) {
    this.validityEnd = validityEnd;
  }


  public TransitMetadata completeValidityStart(@javax.annotation.Nullable String completeValidityStart) {
    this.completeValidityStart = completeValidityStart;
    return this;
  }

  /**
   * Azon időszak kezdete, amelyre az összes szolgáltató biztosít adatot. Több szolgáltató esetén későbbi lehet, mint a &#x60;validityStart&#x60;.
   * @return completeValidityStart
   */
  @javax.annotation.Nullable
  public String getCompleteValidityStart() {
    return completeValidityStart;
  }

  public void setCompleteValidityStart(@javax.annotation.Nullable String completeValidityStart) {
    this.completeValidityStart = completeValidityStart;
  }


  public TransitMetadata completeValidityEnd(@javax.annotation.Nullable String completeValidityEnd) {
    this.completeValidityEnd = completeValidityEnd;
    return this;
  }

  /**
   * Azon időszak vége, amelyre az összes szolgáltató biztosít adatot. Több szolgáltató esetén korábbi lehet, mint a &#x60;validityEnd&#x60;.
   * @return completeValidityEnd
   */
  @javax.annotation.Nullable
  public String getCompleteValidityEnd() {
    return completeValidityEnd;
  }

  public void setCompleteValidityEnd(@javax.annotation.Nullable String completeValidityEnd) {
    this.completeValidityEnd = completeValidityEnd;
  }


  public TransitMetadata lowerLeftLatitude(@javax.annotation.Nullable Double lowerLeftLatitude) {
    this.lowerLeftLatitude = lowerLeftLatitude;
    return this;
  }

  /**
   * A betöltött adatok területének befoglaló téglalapjának két sarokpontja.
   * @return lowerLeftLatitude
   */
  @javax.annotation.Nullable
  public Double getLowerLeftLatitude() {
    return lowerLeftLatitude;
  }

  public void setLowerLeftLatitude(@javax.annotation.Nullable Double lowerLeftLatitude) {
    this.lowerLeftLatitude = lowerLeftLatitude;
  }


  public TransitMetadata lowerLeftLongitude(@javax.annotation.Nullable Double lowerLeftLongitude) {
    this.lowerLeftLongitude = lowerLeftLongitude;
    return this;
  }

  /**
   * A betöltött adatok területének befoglaló téglalapjának két sarokpontja.
   * @return lowerLeftLongitude
   */
  @javax.annotation.Nullable
  public Double getLowerLeftLongitude() {
    return lowerLeftLongitude;
  }

  public void setLowerLeftLongitude(@javax.annotation.Nullable Double lowerLeftLongitude) {
    this.lowerLeftLongitude = lowerLeftLongitude;
  }


  public TransitMetadata upperRightLatitude(@javax.annotation.Nullable Double upperRightLatitude) {
    this.upperRightLatitude = upperRightLatitude;
    return this;
  }

  /**
   * A betöltött adatok területének befoglaló téglalapjának két sarokpontja.
   * @return upperRightLatitude
   */
  @javax.annotation.Nullable
  public Double getUpperRightLatitude() {
    return upperRightLatitude;
  }

  public void setUpperRightLatitude(@javax.annotation.Nullable Double upperRightLatitude) {
    this.upperRightLatitude = upperRightLatitude;
  }


  public TransitMetadata upperRightLongitude(@javax.annotation.Nullable Double upperRightLongitude) {
    this.upperRightLongitude = upperRightLongitude;
    return this;
  }

  /**
   * A betöltött adatok területének befoglaló téglalapjának két sarokpontja.
   * @return upperRightLongitude
   */
  @javax.annotation.Nullable
  public Double getUpperRightLongitude() {
    return upperRightLongitude;
  }

  public void setUpperRightLongitude(@javax.annotation.Nullable Double upperRightLongitude) {
    this.upperRightLongitude = upperRightLongitude;
  }


  public TransitMetadata boundingPolyLine(@javax.annotation.Nullable String boundingPolyLine) {
    this.boundingPolyLine = boundingPolyLine;
    return this;
  }

  /**
   * A betöltött adatokat határoló sokszög vonala (polyline).
   * @return boundingPolyLine
   */
  @javax.annotation.Nullable
  public String getBoundingPolyLine() {
    return boundingPolyLine;
  }

  public void setBoundingPolyLine(@javax.annotation.Nullable String boundingPolyLine) {
    this.boundingPolyLine = boundingPolyLine;
  }


  public TransitMetadata alertIds(@javax.annotation.Nullable List<String> alertIds) {
    this.alertIds = alertIds;
    return this;
  }

  public TransitMetadata addAlertIdsItem(String alertIdsItem) {
    if (this.alertIds == null) {
      this.alertIds = new ArrayList<>();
    }
    this.alertIds.add(alertIdsItem);
    return this;
  }

  /**
   * Az egész alkalmazásra vonatkozó aktív zavarok azonosítói.
   * @return alertIds
   */
  @javax.annotation.Nullable
  public List<String> getAlertIds() {
    return alertIds;
  }

  public void setAlertIds(@javax.annotation.Nullable List<String> alertIds) {
    this.alertIds = alertIds;
  }


  public TransitMetadata feedIds(@javax.annotation.Nullable List<String> feedIds) {
    this.feedIds = feedIds;
    return this;
  }

  public TransitMetadata addFeedIdsItem(String feedIdsItem) {
    if (this.feedIds == null) {
      this.feedIds = new ArrayList<>();
    }
    this.feedIds.add(feedIdsItem);
    return this;
  }

  /**
   * Az aktív adatforrások azonosítói.
   * @return feedIds
   */
  @javax.annotation.Nullable
  public List<String> getFeedIds() {
    return feedIds;
  }

  public void setFeedIds(@javax.annotation.Nullable List<String> feedIds) {
    this.feedIds = feedIds;
  }


  public TransitMetadata dayTypes(@javax.annotation.Nullable Map<String, String> dayTypes) {
    this.dayTypes = dayTypes;
    return this;
  }

  public TransitMetadata putDayTypesItem(String key, String dayTypesItem) {
    if (this.dayTypes == null) {
      this.dayTypes = new HashMap<>();
    }
    this.dayTypes.put(key, dayTypesItem);
    return this;
  }

  /**
   * A menetrendi napok, és a hozzá tartozó napok típusát tartalmazó összerendelés egy hétre (az aktuális nap, és a következő 6).
   * @return dayTypes
   */
  @javax.annotation.Nullable
  public Map<String, String> getDayTypes() {
    return dayTypes;
  }

  public void setDayTypes(@javax.annotation.Nullable Map<String, String> dayTypes) {
    this.dayTypes = dayTypes;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TransitMetadata transitMetadata = (TransitMetadata) o;
    return Objects.equals(this.time, transitMetadata.time) &&
        Objects.equals(this.timeZone, transitMetadata.timeZone) &&
        Objects.equals(this.readableTime, transitMetadata.readableTime) &&
        Objects.equals(this.validityStart, transitMetadata.validityStart) &&
        Objects.equals(this.validityEnd, transitMetadata.validityEnd) &&
        Objects.equals(this.completeValidityStart, transitMetadata.completeValidityStart) &&
        Objects.equals(this.completeValidityEnd, transitMetadata.completeValidityEnd) &&
        Objects.equals(this.lowerLeftLatitude, transitMetadata.lowerLeftLatitude) &&
        Objects.equals(this.lowerLeftLongitude, transitMetadata.lowerLeftLongitude) &&
        Objects.equals(this.upperRightLatitude, transitMetadata.upperRightLatitude) &&
        Objects.equals(this.upperRightLongitude, transitMetadata.upperRightLongitude) &&
        Objects.equals(this.boundingPolyLine, transitMetadata.boundingPolyLine) &&
        Objects.equals(this.alertIds, transitMetadata.alertIds) &&
        Objects.equals(this.feedIds, transitMetadata.feedIds) &&
        Objects.equals(this.dayTypes, transitMetadata.dayTypes);
  }

  @Override
  public int hashCode() {
    return Objects.hash(time, timeZone, readableTime, validityStart, validityEnd, completeValidityStart, completeValidityEnd, lowerLeftLatitude, lowerLeftLongitude, upperRightLatitude, upperRightLongitude, boundingPolyLine, alertIds, feedIds, dayTypes);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TransitMetadata {\n");
    sb.append("    time: ").append(toIndentedString(time)).append("\n");
    sb.append("    timeZone: ").append(toIndentedString(timeZone)).append("\n");
    sb.append("    readableTime: ").append(toIndentedString(readableTime)).append("\n");
    sb.append("    validityStart: ").append(toIndentedString(validityStart)).append("\n");
    sb.append("    validityEnd: ").append(toIndentedString(validityEnd)).append("\n");
    sb.append("    completeValidityStart: ").append(toIndentedString(completeValidityStart)).append("\n");
    sb.append("    completeValidityEnd: ").append(toIndentedString(completeValidityEnd)).append("\n");
    sb.append("    lowerLeftLatitude: ").append(toIndentedString(lowerLeftLatitude)).append("\n");
    sb.append("    lowerLeftLongitude: ").append(toIndentedString(lowerLeftLongitude)).append("\n");
    sb.append("    upperRightLatitude: ").append(toIndentedString(upperRightLatitude)).append("\n");
    sb.append("    upperRightLongitude: ").append(toIndentedString(upperRightLongitude)).append("\n");
    sb.append("    boundingPolyLine: ").append(toIndentedString(boundingPolyLine)).append("\n");
    sb.append("    alertIds: ").append(toIndentedString(alertIds)).append("\n");
    sb.append("    feedIds: ").append(toIndentedString(feedIds)).append("\n");
    sb.append("    dayTypes: ").append(toIndentedString(dayTypes)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("time");
    openapiFields.add("timeZone");
    openapiFields.add("readableTime");
    openapiFields.add("validityStart");
    openapiFields.add("validityEnd");
    openapiFields.add("completeValidityStart");
    openapiFields.add("completeValidityEnd");
    openapiFields.add("lowerLeftLatitude");
    openapiFields.add("lowerLeftLongitude");
    openapiFields.add("upperRightLatitude");
    openapiFields.add("upperRightLongitude");
    openapiFields.add("boundingPolyLine");
    openapiFields.add("alertIds");
    openapiFields.add("feedIds");
    openapiFields.add("dayTypes");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to TransitMetadata
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TransitMetadata.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TransitMetadata is not found in the empty JSON string", TransitMetadata.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!TransitMetadata.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `TransitMetadata` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("timeZone") != null && !jsonObj.get("timeZone").isJsonNull()) && !jsonObj.get("timeZone").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timeZone` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timeZone").toString()));
      }
      if ((jsonObj.get("readableTime") != null && !jsonObj.get("readableTime").isJsonNull()) && !jsonObj.get("readableTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `readableTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("readableTime").toString()));
      }
      if ((jsonObj.get("validityStart") != null && !jsonObj.get("validityStart").isJsonNull()) && !jsonObj.get("validityStart").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `validityStart` to be a primitive type in the JSON string but got `%s`", jsonObj.get("validityStart").toString()));
      }
      if ((jsonObj.get("validityEnd") != null && !jsonObj.get("validityEnd").isJsonNull()) && !jsonObj.get("validityEnd").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `validityEnd` to be a primitive type in the JSON string but got `%s`", jsonObj.get("validityEnd").toString()));
      }
      if ((jsonObj.get("completeValidityStart") != null && !jsonObj.get("completeValidityStart").isJsonNull()) && !jsonObj.get("completeValidityStart").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `completeValidityStart` to be a primitive type in the JSON string but got `%s`", jsonObj.get("completeValidityStart").toString()));
      }
      if ((jsonObj.get("completeValidityEnd") != null && !jsonObj.get("completeValidityEnd").isJsonNull()) && !jsonObj.get("completeValidityEnd").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `completeValidityEnd` to be a primitive type in the JSON string but got `%s`", jsonObj.get("completeValidityEnd").toString()));
      }
      if ((jsonObj.get("boundingPolyLine") != null && !jsonObj.get("boundingPolyLine").isJsonNull()) && !jsonObj.get("boundingPolyLine").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `boundingPolyLine` to be a primitive type in the JSON string but got `%s`", jsonObj.get("boundingPolyLine").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("alertIds") != null && !jsonObj.get("alertIds").isJsonNull() && !jsonObj.get("alertIds").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `alertIds` to be an array in the JSON string but got `%s`", jsonObj.get("alertIds").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("feedIds") != null && !jsonObj.get("feedIds").isJsonNull() && !jsonObj.get("feedIds").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `feedIds` to be an array in the JSON string but got `%s`", jsonObj.get("feedIds").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TransitMetadata.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TransitMetadata' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TransitMetadata> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TransitMetadata.class));

       return (TypeAdapter<T>) new TypeAdapter<TransitMetadata>() {
           @Override
           public void write(JsonWriter out, TransitMetadata value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TransitMetadata read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of TransitMetadata given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of TransitMetadata
   * @throws IOException if the JSON string is invalid with respect to TransitMetadata
   */
  public static TransitMetadata fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TransitMetadata.class);
  }

  /**
   * Convert an instance of TransitMetadata to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

